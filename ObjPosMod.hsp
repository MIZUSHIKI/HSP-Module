//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣
// Object Pos Module                                                    Ver. 2.0
//==============================================================================
// 使い方
//   1. スクリプトの冒頭で#include "ObjPosMod.hsp"。
//   2. buttonやboxf等のオブジェクトに対し、Ctrlを押しながらマウスの左ドラッグで
//      位置を変更、右ドラッグでサイズを変更できるようになる。
//   3. リストからスクリプトを書き換えたいオブジェクトを選択し「スクリプト変更」
//      ボタンを押すと、スクリプトエディタ上の文字が書き換えられる。
//      (エディタで開いてない場合は「ファイルを開く」ボタンになる。)
//   
//  ※1 オブジェクト操作時にあわせて+Shiftも押すと移動の縦横制限をしたり、サイズ
//      を縦横同時に合わせることができる。
//  ※2 矩形複数選択 ... 左ドラッグ : オブジェクトを完全に囲んだものを選択
//                       右ドラッグ : オブジェクトと矩形が重なったものを選択
//
// 対応環境 : Windows8以降、HSP3.6以降
//==============================================================================
// モジュール
// #module ObjPosModScriptClass :スクリプト管理クラス
// #module ObjPosModExpClass    :ObjPosMod拡張クラス
// #module ObjPosModDataClass   :オブジェクトのクラス
// #module ObjPosModHsedModule  :スクリプトエディタ操作用モジュール
// #module ObjPosMod            :ObjPosMod本体
//------------------------------------------------------------------------------
#ifdef _debug
#ifndef __ObjPosMod__
#define __ObjPosMod__

#include "modclbk3.hsp"
#include "mod_regexp.as"

#define _MODULE_NAME_@ObjPosMod "Object Pos Module"
#define _MODULE_VERSION_@ObjPosMod "2.0"

//--------------------------------------
// システム変数
//======================================
// _ObjPosMod_BlankWinID_  :空きIDの登録(これ以降のIDを使わせてもらう。何も指定されていない場合、自動でID10000以上が使用されます)
// _ObjPosMod_BlackListID_ :ウィンドウIDブラックリスト[配列可](ここにあるIDのウィンドウはスルーされる)
// _ObjPosMod_WhiteListID_ :ウィンドウIDホワイトリスト[配列可](ブラックリストの指定がなくホワイトリストだけ指定された場合、ホワイトリストに無いウィンドウIDはスルーされる)
//--------------------------------------
;空きID
#ifndef _ObjPosMod_BlankWinID_
if _ObjPosMod_BlankWinID_ = 0 : _ObjPosMod_BlankWinID_ = 10000
#endif
;ON/OFFリスト
#ifndef _ObjPosMod_BlackListID_
dim _ObjPosMod_BlackListID_, 1 : _ObjPosMod_BlackListID_ = -1
#endif
#ifndef _ObjPosMod_WhiteListID_
dim _ObjPosMod_WhiteListID_, 1 : _ObjPosMod_WhiteListID_ = -1
#endif
;各module内の変数初期化
varinit@ObjPosModScriptClass
varinit@ObjPosModDataClass
varinit@ObjPosMod

//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣
// ObjPosModスクリプト管理クラス(モジュール型変数)
//==============================================================================
// hspFile :スクリプトのファイルパス
// script  :スクリプト全文
//------------------------------------------------------------------------------
#module ObjPosModScriptClass \
	hspFile, \
	script

//--------------------------------------
// モジュール変数名定義(モジュール内省略の為)
//--------------------------------------
#define objScript objScript@ObjPosModDataClass

//--------------------------------------
// 変数初期化
//--------------------------------------
#deffunc local varinit
	;カレントディレクトリを保持しておく
	dirCurrent = dir_cur
	return
	
//--------------------------------------
// コンストラクタ
//--------------------------------------
#modinit str _hspFile, str _script
	hspFile = _hspFile
	script = _script

	if vartype( hsptmp_ ) = 4 {
		hsptmp_ = ""
		exist dirCurrent+"\\hsptmp"
		if strsize ! -1 {
			sdim hsptmp_, strsize+1
			bload dirCurrent+"\\hsptmp", hsptmp_, strsize
		}
		//HSEDぐるっと回してhsptmpと一致するファイル名(タブ)を取得しておく
		hsptmp_filename_ = HSED_GetFilename@ObjPosModHsedModule( hsptmp_ )
	}
	
	mref thisID, 2
	return thisID

//--------------------------------------
// Getter Settter
//--------------------------------------
#modcfunc local hspFile_
	return hspFile
#modcfunc local script_
	return script
#modfunc local _Set_script_ str p1
	script = p1 : return

//--------------------------------------
// スクリプト読み込み
//--------------------------------------
#deffunc local Load_script_ str _hspFile
	hspFilePath = Get_fullPath_(_hspFile)
	if _hspFile = "???" || hspFilePath = hsptmp_filename_ {
		if hsptmp_filename_ ! "" : hsptmp_ = HSED_GetScript@ObjPosModHsedModule( hsptmp_filename_ ) ;エディタからスクリプト更新(無題だったら持ってるhsptmpで強行する)
		return -1 ;新規読み込みでない
	}
	cn = -1
	foreach objScript
		if hspFile_(objScript.cnt) = hspFilePath : cn = cnt : break
	loop
	if cn = -1 {
		//まだ読み込んでないなら追加
		exist hspFilePath
		if strsize ! -1 {
			sdim fullScript, strsize+1
			bload hspFilePath, fullScript, strsize
			newmod objScript, ObjPosModScriptClass, hspFilePath, fullScript
			return stat ;新規読み込みはモジュールIDを返す
		}
	}else {
		//読み込み済みで強制ロードなら更新
		_Set_script_ objScript.cn, HSED_GetScript@ObjPosModHsedModule( hspFilePath ) ;エディタからスクリプト取得
	}
	return -1 ;新規読み込みでない

//--------------------------------------
// 指定hspファイルのスクリプトを返す
//--------------------------------------
#defcfunc local Get_script_ str _hspFile
	hspFilePath = Get_fullPath_(_hspFile)
	if _hspFile = "???" || hspFilePath = hsptmp_filename_ : return hsptmp_
	cn = -1
	foreach objScript
		if hspFile_(objScript.cnt) = hspFilePath : cn = cnt : break
	loop
	if cn = -1 : Load_script_ _hspFile : cn = stat //もしまだ持ってないならロード
	if cn = -1 : return ""
	return script_(objScript.cn)
	
//--------------------------------------
// 読み込み済みのスクリプトを指定したものに更新
//--------------------------------------
#deffunc local Set_script_ str _hspFile, var _script
	hspFilePath = Get_fullPath_(_hspFile)
	if _hspFile = "???" || hspFilePath = hsptmp_filename_ {
		 hsptmp_ = _script
		return
	}
	cn = -1
	foreach objScript
		if hspFile_(objScript.cnt) = hspFilePath : cn = cnt : break
	loop
	if cn = -1 : newmod objScript, ObjPosModScriptClass, hspFilePath, _script : return //もしまだ持ってないならnewmod
	_Set_script_ objScript.cn, _script
	return

//--------------------------------------
// 相対パスの場合、カレントとcommonのファイル有無を調べて絶対パスを返す
//--------------------------------------
#defcfunc local Get_fullPath_ str _hspFile
	hspFilePath = _hspFile
	if strmid( hspFilePath, 1, 2 ) = ":\\" : return _hspFile ;絶対パス
	hspFileCurrentPath = dirCurrent+"\\"+_hspFile
	hspFileCommonPath  = dir_exe+"\\common\\"+_hspFile
	;existを極力減らすため読み込んだことがある(存在を知っている)ファイルがあるか探す
	cn = -1
	foreach objScript
		if hspFile_(objScript.cnt) = hspFileCurrentPath || hspFile_(objScript.cnt) = hspFileCommonPath : cn = cnt : break
	loop
	if cn ! -1 : return hspFile_(objScript.cn)
	exist dir_exe+"\\common\\"+hspFilePath
	if strsize!-1 : return dir_exe+"\\common\\"+_hspFile
	return dirCurrent+"\\"+_hspFile

#global
//------------------------------------------------------------------------------
// End of ObjPosModスクリプト管理クラス(モジュール型変数)
//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿


//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣
// ObjPosMod拡張クラス(モジュール型変数)
//==============================================================================
// exobjFileName       :ObjPosModの拡張モジュールを記述しているhspファイル名
// hspFileName         :拡張オブジェクトが記述されているhspファイル名(将来的に利用したい)
// objType             :拡張オブジェクトの名前[#deffunc名](複数deffuncまたいで使用しているlineやmesをリストに出したくない場合は「拡張オブジェクト名|無視deffunc1|無視deffunc2|・・・」とする)
// layeredType         :オブジェクト選択時の表示タイプ(0:winobjタイプ, 1:bgscrタイプ)、描画リフレッシュ処理が必要なとき(+2:追加オプション)[ほぼGroupBox用]
// label_RewriteScript :エディタ書き換え処理を登録するラベル
// label_ListDetail    :ObjPosModのリストの備考に何を書くかを登録するラベル
// label_HitTest       :オブジェクトをマウスで選択するときの特殊条件を登録するラベル
// label_RedrawObj     :オブジェクトサイズ変更時に独自描画が必要な場合に登録するラベル
//------------------------------------------------------------------------------
#module ObjPosModExpClass \
	exobjFileName, \
	hspFileName, \
	objType, \
	layeredType, \
	label_RewriteScript, \
	label_ListDetail, \
	label_HitTest, \
	label_RedrawObj

//--------------------------------------
// 記号定数
//--------------------------------------
#const AFFECTOPTION_CurrentPos 1
#const AFFECTOPTION_Objsize 2
#const AFFECTOPTION_Font 4

//--------------------------------------
// モジュール変数名定義(モジュール内省略の為)
//--------------------------------------
#define objExp objExp@ObjPosModDataClass

//--------------------------------------
// Expオブジェクト登録命令(ユーザー用)
//--------------------------------------
#define global ObjPosModExp_AddObjType(%1,%2,%3=0,%4=0,%5=0,%6=0,%7=0,%8=0) ScFile@ObjPosModExpClass=__file__ : _lbl1_@ObjPosModExpClass=%5 : _lbl2_@ObjPosModExpClass=%6 : _lbl3_@ObjPosModExpClass=%7 : _lbl4_@ObjPosModExpClass=%8 : _ObjPosModExp_AddObjType@ObjPosModExpClass %1,%2,%3,%4
#deffunc local _ObjPosModExp_AddObjType str p1, str p2, int p3, int p4
	if vartype( _lbl1_ ) ! 1 : _lbl1_ = *DummyLabel@ObjPosModExpClass
	if vartype( _lbl2_ ) ! 1 : _lbl2_ = *DummyLabel@ObjPosModExpClass
	if vartype( _lbl3_ ) ! 1 : _lbl3_ = *DummyLabel@ObjPosModExpClass
	if vartype( _lbl4_ ) ! 1 : _lbl4_ = *DummyLabel@ObjPosModExpClass
	newmod objExp@ObjPosModDataClass, ObjPosModExpClass, ScFile, p1, p2, p3, p4, _lbl1_, _lbl2_, _lbl3_, _lbl4_
	return
	
//--------------------------------------
// コンストラクタ
//--------------------------------------
#modinit str _exobjFileName, str _hspFileName, str _objType, int _affectOption, int _layeredType, label _label_RewriteScript, label _label_ListDetail, label _label_HitTest, label _label_RedrawObj
	exobjFileName = _exobjFileName
	hspFileName = _hspFileName
	objType = _objType
	layeredType = _layeredType
	label_RewriteScript = _label_RewriteScript
	label_ListDetail = _label_ListDetail
	label_HitTest = _label_HitTest
	label_RedrawObj = _label_RedrawObj
	split objType, "|", objnames
	objnames = strtrim(objnames)
	if objnames ! "" {
		if _affectOption & AFFECTOPTION_CurrentPos : funcnameChangesCurrent_@ObjPosModDataClass( length.funcnameChangesCurrent_ ) = objnames
		if _affectOption & AFFECTOPTION_Objsize    : funcnameAffectedSize_objsize_@ObjPosModDataClass( length.funcnameAffectedSize_objsize_ ) = objnames
		if _affectOption & AFFECTOPTION_Font       : funcnameAffectedSize_font_@ObjPosModDataClass( length.funcnameAffectedSize_font_ ) = objnames
	}
	return

//--------------------------------------
// Getter Settter
//--------------------------------------
#modcfunc local exobjFileName_
	return exobjFileName
#modcfunc local hspFileName_
	return hspFileName
#modcfunc local objType_
	split objType, "|", funcs : return funcs.0
#modcfunc local objTypes_
	return objType
#modcfunc local layeredType_
	return layeredType
#modfunc local label_RewriteScript_
	refLabel = label_RewriteScript : return
#modfunc local label_ListDetail_
	refLabel = label_ListDetail : return
#modfunc local label_HitTest_
	refLabel = label_HitTest : return
#modfunc local label_RedrawObj_
	refLabel = label_RedrawObj : return

//--------------------------------------
// 拡張命令として登録されているオブジェクト内で使用されている命令かどうか
//--------------------------------------
#defcfunc local IsInsideExpObj str _scFile, int _scLine
	ret = 1
	filename = getpath( _scFile, 8+16 )
	//まず_scFileがそもそもobjExpに登録されているか確認しておく(ここで弾かれればまだ処理軽い)
	foreach objExp
		if filename = getpath( exobjFileName_(objExp.cnt), 8+16 ) : ret = 0 : break //将来的に exobjFileName_ → hspFileName_ に出来たら良いなぁ。
	loop
	if ret = 1 : return 0
	hspDefFunc = getpath( GetHspDefFunc_( _scFile, _scLine ), 16 ) ;mesやlineの命令が何の#deffunc内で使われているかを取得
	if hspDefFunc = "" : return 0
	foreach objExp
		if filename = getpath( exobjFileName_(objExp.cnt), 8+16 ) { //将来的に exobjFileName_ → hspFileName_ に出来たら良いなぁ。
			objtype_buf = objTypes_(objExp.cnt) : split objtype_buf, "|", objtypes
			repeat stat
				if getpath( objtypes.cnt, 16 ) = hspDefFunc : ret = 1 : break
			loop
			if ret = 1 : break
		}
	loop
	return ret
	
//--------------------------------------
//  何の#deffuncに属しているか取得する(実際とは異なる場合があるので注意)
//--------------------------------------
#defcfunc local GetHspDefFunc_ str _scFile, int _scLine, \
local result
	// フルスクリプトを貰って検索する
	fullScript_buf = Get_script_@ObjPosModScriptClass( _scFile )
	GetIndex_toFuncAndLineHead@ObjPosModDataClass index_toFunc, index_lineHead, fullScript_buf, _scLine, "" ;指定Line行頭までのindexを取得(index_toFunc==-1)
	script_buf_before = strmid( fullScript_buf, 0, index_lineHead )
	;#globalがあるならそこまではざっくりカットしてしまう
	matches result, script_buf_before, "^(?:.|\n)*#global((?:.|\n)*)$", 0, 0, 1
	if stat ! 0 : script_buf_before = result( stat-1, 1 )

	;最後に見つかった#deffuncに属しているものとして取得する(ただし実際は異なる場合がある。returnを気にしたいがスコープを探るのが辛い)
	matches result, script_buf_before, "#defc?func[ \t]+(?:local[ \t]+)?(\\w+)", 0, 0, 1
	if stat ! 0 {
		result = result( stat-1, 1 )
	}else {
		result = ""
	}
	return result

//--------------------------------------
// ダミーラベル
//--------------------------------------
*DummyLabel@ObjPosModExpClass
	return

#global
//------------------------------------------------------------------------------
// End of オブジェクトのクラス(モジュール型変数)
//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿


//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣
// オブジェクトのクラス(モジュール型変数)
//==============================================================================
// winID        :オブジェクトを配置したウィンドウのID
// winHwnd      :オブジェクトを配置したウィンドウのhWnd
// objID        :オブジェクトのID
// objHwnd      :オブジェクトのhWnd
// objType      :オブジェクトのタイプ("mes","button"等)
// pos_xy0      :オブジェクトの位置(初期)
// pos_xy1      :オブジェクトの位置(移動中)
// pos_xy2      :オブジェクトの位置(移動後)
// size_wh0     :オブジェクトのサイズ(初期)
// size_wh1     :オブジェクトのサイズ(変更中)
// size_wh2     :オブジェクトのサイズ(変更後)
// objed_cxy    :オブジェクトを配置したときの元のカレントポジション
// objsz_py     :オブジェクトを配置したときのobjsize p3(Y方向の最低確保行サイズ)
// colorRGB     :オブジェクトを配置したときのカレントカラー
// hspLine      :オブジェクトを配置したときのHSPファイルの行数
// hspFile      :オブジェクトを配置したときのHSPファイル名
// changedCount :オブジェクトを変更したかのフラグ(全体を通して自動カウントした数値が入る)
// maeScript    :変更前のスクリプト(変更必要箇所抜き出し)
// atoScript    :変更後のスクリプト(変更必要箇所抜き出し)
// fullScript   :モジュール変数としては今は使ってない。スクリプト管理クラスを噛ませて取り出している。
// hasBeenFixed :スクリプトが修正済みかのフラグ
// opt1〜       ;上記以外でオブジェクトに必要なデータを保存(objTypeによって変数の型が異なる)
//------------------------------------------------------------------------------
#module ObjPosModDataClass \
	modID, \
	winID, \
	winHwnd, \
	objID, \
	objHwnd, \
	objType, \
	pos_x0, pos_y0, \
	pos_x1, pos_y1, \
	pos_x2, pos_y2, \
	size_w0, size_h0, \
	size_w1, size_h1, \
	size_w2, size_h2, \
	objed_cx, objed_cy, \
	objsz_py, \
	colorR, colorG, colorB, \
	hspLine, \
	hspFile, \
	hspDefFunc, \
	changedCount, \
	maeScript, atoScript, \
	fullScript, \
	hasBeenFixed, \
	opt1, opt2, opt3, opt4, opt5, opt6, opt7

//--------------------------------------
// 記号定数
//--------------------------------------
#const INT_MAX 2147483647
//--------------------------------------
// 変数初期化
//--------------------------------------
#deffunc local varinit
	;hsptmp拾い用にカレントディレクトリを保持しておく
	dirCurrent = dir_cur
	//Update_MaeAtoScript_で使う配列の初期化
	funcnameChangesCurrent_       = "mes", "line", "chkbox", "mesbox", "input", "combox", "listbox", "winobj", "button", "pos"
	scopeBreakerReg_before_       = "(\n|:|\\{|[ \t])return(\n|:|\\}|[ \t])", "(\n|:|\\{|[ \t])stop(\n|:|\\}|[ \t])", "(?:\n|:|\\{|[ \t])screen[ \t]+", "(?:\n|:|\\{|[ \t])bgscr[ \t]+", "(?:\n|:|\\{|[ \t])buffer[ \t]+", "(?:\n|:|\\{|[ \t])gsel[ \t]+", "\\}", "\\*[A-Za-z_]\w*?(\n|:|\\}|[ \t])"
	scopeBreakerReg_after_pos_    = "(\n|:|\\{|[ \t])return(\n|:|\\}|[ \t])", "(\n|:|\\{|[ \t])stop(\n|:|\\}|[ \t])", "(?:\n|:|\\{|[ \t])screen[ \t]+", "(?:\n|:|\\{|[ \t])bgscr[ \t]+", "(?:\n|:|\\{|[ \t])buffer[ \t]+", "(?:\n|:|\\{|[ \t])gsel[ \t]+", "(?:\n|:|\\{|[ \t])line[ \t]+.*?,.*?,.+?,.+?"
	scopeBreakerReg_after_size_   = "(\n|:|\\{|[ \t])return(\n|:|\\}|[ \t])", "(\n|:|\\{|[ \t])stop(\n|:|\\}|[ \t])", "(?:\n|:|\\{|[ \t])screen[ \t]+", "(?:\n|:|\\{|[ \t])bgscr[ \t]+", "(?:\n|:|\\{|[ \t])buffer[ \t]+", "(?:\n|:|\\{|[ \t])gsel[ \t]+"
	funcnameAffectedSize_font_    = "mes"
	funcnameAffectedSize_objsize_ = "chkbox", "mesbox", "input", "combox", "listbox", "winobj", "button"
	;モジュール変数の初期化
	newmod objExp, ObjPosModExpClass, "", "", "", 0, 0, *DummyLabel@ObjPosModExpClass, *DummyLabel@ObjPosModExpClass, *DummyLabel@ObjPosModExpClass, *DummyLabel@ObjPosModExpClass
	delmod objExp.0
	newmod objScript, ObjPosModScriptClass, "", ""
	delmod objScript.0
	return

//--------------------------------------
// コンストラクタ
//--------------------------------------
#modinit int _winid, int _winHwnd, int _objID, int _objHwnd, str _objType, int _pos_x0, int _pos_y0, int _size_w0, int _size_h0, int _objed_cx, int _objed_cy, int _objsz_py, int _colorR, int _colorG, int _colorB, str _hspFile, int _hspLine
	modID = modID_counter_ : modID_counter_++
	winID = _winid
	winHwnd = _winHwnd
	objID = _objID
	objHwnd = _objHwnd
	objType = _objType
	pos_x0 = _pos_x0
	pos_y0 = _pos_y0
	pos_x1 = pos_x0
	pos_y1 = pos_y0
	pos_x2 = pos_x0
	pos_y2 = pos_y0
	size_w0 = _size_w0 : if size_w0 < 0 : size_w0 = 0
	size_h0 = _size_h0 : if size_h0 < 0 : size_h0 = 0 
	size_w1 = size_w0
	size_h1 = size_h0
	size_w2 = size_w0
	size_h2 = size_h0
	objed_cx = _objed_cx
	objed_cy = _objed_cy
	objsz_py = _objsz_py
	colorR = _colorR
	colorG = _colorG
	colorB = _colorB
	hspFile = _hspFile
	hspLine = _hspLine
	changedCount = 0
	maeScript = ""
	atoScript = ""
	fullScript = ""
	hasBeenFixed = 0
	
	mref thisID, 2
	return thisID

//--------------------------------------
// 既にファイル/行/命令が同一のオブジェクトが作られていないかnewmodする前に確認 (ループ内の描画オブジェクトは最初の１つだけを扱う為)
//--------------------------------------
#defcfunc local isCreated array mod, str _hspFile, int _hspLine, str _objType
	flg = 0
	foreach mod
		if hspFile_(mod.cnt)=_hspFile & hspLine_(mod.cnt)=_hspLine & objType_(mod.cnt)=_objType : flg = 1 : break
	loop
	return flg

//--------------------------------------
// Getter Settter
//--------------------------------------
#modcfunc local modID_
	return modID
#modcfunc local winID_
	return winID
#modcfunc local winHwnd_
	return winHwnd
#modcfunc local objID_
	return objID
#modcfunc local objHwnd_
	return objHwnd
#modcfunc local pos_x0_
	return pos_x0
#modcfunc local pos_y0_
	return pos_y0
#modcfunc local pos_x1_
	return pos_x1
#modfunc local Set_pos_x1_ int p1
	pos_x1 = p1 : return
#modcfunc local pos_y1_
	return pos_y1
#modfunc local Set_pos_y1_ int p1
	pos_y1 = p1 : return
#modcfunc local pos_x2_
	return pos_x2
#modfunc local Set_pos_x2_ int p1
	pos_x2 = p1 : return
#modcfunc local pos_y2_
	return pos_y2
#modfunc local Set_pos_y2_ int p1
	pos_y2 = p1 : return
#modcfunc local size_w0_
	return size_w0
#modcfunc local size_h0_
	return size_h0
#modcfunc local size_w1_
	return size_w1
#modfunc local Set_size_w1_ int p1
	size_w1 = p1 : if p1<0 { size_w1 = 0 } : return
#modcfunc local size_h1_
	return size_h1
#modfunc local Set_size_h1_ int p1
	size_h1 = p1 : if p1<0 { size_h1 = 0 } : return
#modcfunc local size_w2_
	return size_w2
#modfunc local Set_size_w2_ int p1
	size_w2 = p1 : if p1<0 { size_w2 = 0 } : return
#modcfunc local size_h2_
	return size_h2
#modfunc local Set_size_h2_ int p1
	size_h2 = p1 : if p1<0 { size_h2 = 0 } : return
#modcfunc local objed_cx_
	return objed_cx
#modcfunc local objed_cy_
	return objed_cy
#modcfunc local objsz_py_
	return objsz_py
#modcfunc local colorR_
	return colorR
#modcfunc local colorG_
	return colorG
#modcfunc local colorB_
	return colorB
#modcfunc local objType_
	return objType
#modcfunc local hspFile_
	return hspFile
#modcfunc local hspLine_
	return hspLine
#modcfunc local changedCount_
	return changedCount
#modcfunc local maeScript_
	return maeScript
#modfunc local Set_maeScript_ str p1
	maeScript = p1 : return
#modcfunc local atoScript_
	return atoScript
#modfunc local Set_atoScript_ str p1
	atoScript = p1 : return
#modcfunc local _fullScript_
	return fullScript
#modfunc local _Set_fullScript_ str p1
	fullScript = p1 : return
#modcfunc local _hspDefFunc_
	return hspDefFunc
#modfunc local _Set_hspDefFunc_ str p1
	hspDefFunc = p1 : return
#modcfunc local hasBeenFixed_
	return hasBeenFixed
#modfunc local Set_hasBeenFixed_ int p1
	hasBeenFixed = p1 : return

//--------------------------------------
// 特殊Getter (ObjPosModスクリプト管理クラスとの橋渡し)
//======================================
// MODE_OverwriteHsed_==1 (NeedReload_fullScript内) :Update_MaeAtoScript_内でエディタのスクリプトを書き換えるため、エディタから引っ張ってきて最新のスクリプトに更新する
//--------------------------------------
#modcfunc local fullScript_
	if NeedReload_fullScript( hspFile ) : Load_script_@ObjPosModScriptClass hspFile
	//ファイル名から
	return Get_script_@ObjPosModScriptClass( hspFile )
//--------------------------------------
// スクリプトエディタ書き込み時はモード変更する(fullScript_取得の際スクリプトを再読み込み)
//--------------------------------------
#deffunc local SetMode_OverwriteHsed_ int p1
	MODE_OverwriteHsed_ = (p1!=0)
	sdim reloadedFile, 1024, 1 ;モード変更時に初期化
	reloadedCount = 0
	return
#defcfunc local NeedReload_fullScript str filename ;Needを問われる度に無ければ追加していく
	if MODE_OverwriteHsed_ = 0 : return 0
	reloaded = 0
	repeat reloadedCount
		if reloadedFile(cnt) = filename : reloaded = 1 : break
	loop
	if reloaded = 0 : reloadedFile( reloadedCount ) = filename : reloadedCount++
	return ( reloaded == 0 )
	
//--------------------------------------
// 特殊Setter (ObjPosModスクリプト管理クラスとの橋渡し)
//--------------------------------------
#modfunc local Set_fullScript_ var script
	Set_script_@ObjPosModScriptClass hspFile, script
	return

//--------------------------------------
// 特殊Setter (2個同時Set、自動カウント)
//--------------------------------------
#modfunc local Set_pos_xy0_ int p1, int p2
	pos_x0 = p1 : pos_y0 = p2 : return
#modfunc local Set_pos_xy1_ int p1, int p2
	pos_x1 = p1 : pos_y1 = p2 : return
#modfunc local Set_pos_xy2_ int p1, int p2
	pos_x2 = p1 : pos_y2 = p2 : return
#modfunc local Set_size_wh0_ int p1, int p2
	size_w0 = p1 : size_h0 = p2 : if p1<0 { size_w0 = 0 } : if p2<0 { size_h0 = 0 } : return
#modfunc local Set_size_wh1_ int p1, int p2
	size_w1 = p1 : size_h1 = p2 : if p1<0 { size_w1 = 0 } : if p2<0 { size_h1 = 0 } : return
#modfunc local Set_size_wh2_ int p1, int p2
	size_w2 = p1 : size_h2 = p2 : if p1<0 { size_w2 = 0 } : if p2<0 { size_h2 = 0 } : return
#modfunc local Set_objed_cxy_ int p1, int p2
	objed_cx = p1 : objed_cy = p2 : return
#modfunc local AutoSet_changedCount_
	changedCounter_++ : changedCount = changedCounter_ : return
	
//--------------------------------------
// Getter Settter (opt項目 : objTypeによって変数の型が異なる。pos,size以外の必要なデータを保存。)
//--------------------------------------
#modcfunc local opt1_
	return opt1
#define global Set_opt1_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt1_@ObjPosModDataClass %1
#modfunc local _Set_opt1_
	opt1 = vt : return
#modcfunc local opt2_
	return opt2
#define global Set_opt2_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt2_@ObjPosModDataClass %1
#modfunc local _Set_opt2_
	opt2 = vt : return
#modcfunc local opt3_
	return opt3
#define global Set_opt3_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt3_@ObjPosModDataClass %1
#modfunc local _Set_opt3_
	opt3 = vt : return
#modcfunc local opt4_
	return opt4
#define global Set_opt4_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt4_@ObjPosModDataClass %1
#modfunc local _Set_opt4_
	opt4 = vt : return
#modcfunc local opt5_
	return opt5
#define global Set_opt5_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt5_@ObjPosModDataClass %1
#modfunc local _Set_opt5_
	opt5 = vt : return
#modcfunc local opt6_
	return opt6
#define global Set_opt6_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt6_@ObjPosModDataClass %1
#modfunc local _Set_opt6_
	opt6 = vt : return
#modcfunc local opt7_
	return opt7
#define global Set_opt7_@ObjPosModDataClass(%1,%2) vt@ObjPosModDataClass=%2 : _Set_opt7_@ObjPosModDataClass %1
#modfunc local _Set_opt7_
	opt7 = vt : return

//--------------------------------------
// modIDと照合して真のモジュールIDを取得(モジュールの順番はデータ削除等を挟むと作成順通りにならないため)
//--------------------------------------
#defcfunc local Get_modID_ array mod, int _id //Get_modID_@ObjPosModDataClass( objData,cnt )って書いてもらう(ドットでなくカンマ)
	id = _id //Exp用処置
	ret = -1
	foreach mod
		if modID_(mod.cnt) = id : ret = cnt : break
	loop
	return ret

//--------------------------------------
// スクリプトエディタでファイルを開いているか
//--------------------------------------
#modcfunc local IsOpenedHspFile_
	if hspFile_( thismod ) = "???" : return 1 ;hsptmp
	hspFilePath = Get_fullPath_@ObjPosModScriptClass( hspFile_( thismod ) )
	return HSED_IsOpenedFile@ObjPosModHsedModule( hspFilePath )

//--------------------------------------
// 入力されたモジュール変数ID配列をスクリプトの末尾にある方から順にソートして返す(書き換え時、新規追加pos等が発生したときにカレント戻しと追加posが被るという意味のない重複を防ぐため)
//--------------------------------------
#deffunc local Get_SortedArray_DescendingScriptLine array mod, array out_modIDs, array modIDs, int modIDs_count, \
local i, \
local len, \
local max, \
local name
	;面倒くさいので先にファイル名をリストにしてしまう
	sdim names, 512,1
	names(0) = hspFile_( mod.modIDs(0) )
	repeat modIDs_count-1, 1
		flg = 0 : cn = cnt
		repeat length.names
			if hspFile_( mod.modIDs(cn) ) = names(cnt) : flg = 1 : break
		loop
		if flg = 1 : continue
		names( length.names ) = hspFile_( mod.modIDs(cn) )
	loop
	;面倒くさいのでmodIDsをコピーして取り出したヤツは-1で消していくことにする
	dim temp_modIDs, modIDs_count
	memcpy temp_modIDs, modIDs, 4 * modIDs_count
	;同じファイル名のものを塊として、hspLine_の若い順にソート
	dim out_modIDs, modIDs_count : i = 0
	repeat length.names
		name = names(cnt)
		repeat modIDs_count
			max = -1 : len = -1
			repeat modIDs_count
				if temp_modIDs(cnt) = -1 : continue
				if hspFile_( mod.temp_modIDs(cnt) ) ! name : continue
				if max < hspLine_( mod.temp_modIDs(cnt) ) : max = hspLine_( mod.temp_modIDs(cnt) ) : len = -1 : cn = cnt : continue
				if max = hspLine_( mod.temp_modIDs(cnt) ) {
					;行数が同じ場合はindexも調査して順番をつける
					if len = -1 {
						;先に控えているだけだったヤツを調査
						fullScript_buf = fullScript_( mod.temp_modIDs(cn) )
						GetIndex_toFuncAndLineHead len, index_lineHead, fullScript_buf, hspLine_( mod.temp_modIDs(cn) ), objType_( mod.temp_modIDs(cn) ) ;objTypeの命令頭までのindex(とその行頭までのindex)を取得
					}
					;後から被りを見つけた方のヤツを調査
					GetIndex_toFuncAndLineHead index_toFunc, index_lineHead, fullScript_buf, hspLine_( mod.temp_modIDs(cnt) ), objType_( mod.temp_modIDs(cnt) )
					if len < index_toFunc : max = hspLine_( mod.temp_modIDs(cnt) ) : cn = cnt
					continue
				}
			loop
			if max = -1 : break
			out_modIDs( i ) = temp_modIDs( cn ) : i++
			temp_modIDs( cn ) = -1
		loop
	loop
	return i

//--------------------------------------
// 内部データを使ってmaeScript,atoScriptを更新 - Update_MaeAtoScript_@ObjPosModDataClass objData,cnt って書いてもらう(ドットでなくカンマ)
//======================================
// MODE_OverwriteHsed_ == 1 :エディタのスクリプトも書き換える
//--------------------------------------
#deffunc local Update_MaeAtoScript_ array mod, int _id, \
local result, \
local _result
	id = _id //Exp用処置

	if hasBeenFixed_( mod.id ) ! 0 : return ;スクリプト書き換え済みだったらそれ以上変更できないようにする

	//--------------------------------------
	// エディタ書き換えの処理配列の初期化（オブジェクトの位置/サイズを変更したときにどういう風にスクリプトを変更していけば良いかの処理を入れる配列）
	//======================================
	// syori_line               :書き換え処理をする行番号
	// syori_index_lineHead     :書き換え行の行頭のindex
	// syori_index_fromLineHead :書き換える文字は行頭から何index目か
	// syori_delete_len         :書き換えで消す文字のbyte数
	// syori_write              :書き換えで消した後に書き込む文字
	// (syori_count)            :処理配列のインデックス
	//--------------------------------------
	dim syori_line, 1
	dim syori_index_lineHead, 1
	dim syori_index_fromLineHead, 1
	dim syori_delete_len, 1
	sdim syori_write, 1024, 1
	syori_count = 0
	
	fullScript_buf = fullScript_( mod.id )
	; fullScript_buf :スクリプト全文
	if fullScript_buf = "" : return ;エディタに書き込み時、最新スクリプトを取得しに行くが問題があった場合空欄が返る -> 処理中止
	
	;objTypeの命令頭までのindexとその行頭までのindexを取得
	GetIndex_toFuncAndLineHead index_toFunc, index_lineHead,  fullScript_buf, hspLine_(mod.id), objType_(mod.id)
	; index_toFunc   :命令(objType_)までのインデックス
	; index_lineHead :命令(objType_)の書いてある行数
	if index_toFunc = -1 :return
	
	switch objType_(mod.id)
		case "mes"
			//------------------------------------------------------------------------------
			// 書き換えの基準について
			//==============================================================================
			// pos : font     
			//             ← mesと一番近いposとの間に邪魔な命令がなければ、このposのパラメータを変化させれば良い。
			// (input)     ← 仮にカレントポジションが変わる命令が間にあったら、適切なposがないのでmes命令直前にposを書き加える必要がある。
			// mes            
			//             ← mesの次のカレントポジションが関わる命令までの間にposがあれば、mesの位置をいじっても後ろの命令に影響を与えない。つまりmes命令直後にカレントポジションを戻す処理を書き加える必要はない。
			// (stop)         ┌→ 但し、(button)との間に仮に(stop)などのカレントポジションのスコープ(関わり)が切れる記述があった場合(このstopがbuttonの手前にあった場合)、posを書き加えるのは冗長になるため必要ない。
			// (button)    ← 仮にカレントポジションに関わる命令があったら、mesのposだけ変えると後ろが全てズレてしまうので、mes命令直後にカレントポジションを戻す処理(pos)を書き加える必要がある。
			// pos            
			//             ※ これのfont版や、他のobjTypeのpos,objsizeも調査して、それぞれ処理方法を決定する。(boxf等、命令によってはパラメータに組み込まれたり、カレントが変更されなかったりとこれらの調査がいらない場合もある。)
			//------------------------------------------------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc ) ;オブジェクト命令の手前のスクリプトを取得
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX ) ;オブジェクト命令から後ろのスクリプトを取得
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after ) ;オブジェクト命令が書いてある行のスクリプト（1行だけ）。文字列やコメントを「X」で置き換えてある。
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				; lineNum_before        :pos命令の書いてある行数
				; indexLineHead_before  :pos命令のある行の行頭までのインデックス
				; indexSubMatch1_before :pos命令のパラメータ手前までのインデックス(submatch文字列の1つ目の結果の長さを返している)
				; lenSubMatch2_before   :pos命令のパラメータ部分の文字列長(submatch文字列の2つ目の結果の長さを返している)
				if stat ! 0 {
					; posが見つかった
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					; posが見つからなかった(または見つかったが間に邪魔者がいたからそのposは使えない)ときはオブジェクト命令手前にposを追記させる
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					; mes令直後にカレントポジションを戻す処理(pos)を書き加える必要がある
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(mes[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			
			//font調査
			if opt4_( mod.id ) ! opt5_( mod.id ) {
				//index_toFunc前のfont調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])font[ \t]+.*?,[ \t]*)("+opt4_(mod.id)+")[ \t]*(?:,|\n|:|;|//|/\\*|\\}|$)", funcnameAffectedSize_font_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+opt5_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "font \""+opt3_( mod.id )+"\", "+opt5_( mod.id )
					if opt6_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+opt6_( mod.id )
					if opt7_( mod.id ) ! 1 {
						if opt6_( mod.id ) = 0 : syori_write( syori_count ) += ", "
						syori_write( syori_count ) += ", "+opt7_( mod.id )
					}
					syori_write( syori_count ) += " : "
					syori_count++
				}
				//index_toFunc後ろのfont調査
				if NeedBackToOriginal_AfterFunc_SubMatch( script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))font[ \t]+", funcnameAffectedSize_font_, scopeBreakerReg_after_size_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(mes[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : font \""+opt3_( mod.id )+"\", "+opt4_( mod.id )
					if opt6_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+opt6_( mod.id )
					if opt7_( mod.id ) ! 1 {
						if opt6_( mod.id ) = 0 : syori_write( syori_count ) += ", "
						syori_write( syori_count ) += ", "+opt7_( mod.id )
					}
					syori_count++
				}
			}
			swbreak
			
		case "boxf"
			//--------------------------------------
			// オブジェクト自身にpos,sizeパラメータがあり、手前や後続に影響を与えない。
			//--------------------------------------
			script_buf_after = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//オブジェクト調査
			matches result, oneLineScript_buf_after_textReplacedDummy, "^(boxf[ \t]+)(.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1
			if stat = 0 : swbreak
			syori_line( syori_count ) = hspLine_(mod.id)
			syori_index_lineHead( syori_count ) = index_lineHead
			syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1)
			syori_delete_len( syori_count ) = strlen.result(0,2)
			syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+", "+( size_w2_(mod.id) + pos_x2_( mod.id ) - 1 )+", "+( size_h2_(mod.id) + pos_y2_( mod.id ) - 1 )
			syori_count++
			swbreak
			
		case "line"
			//--------------------------------------
			// オブジェクト自身にpos,sizeパラメータがあるが、後続には影響を与えてしまう。後ろだけpos調査。
			//--------------------------------------
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//index_toFunc後ろのpos調査
			if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
				syori_line( syori_count ) = hspLine_(mod.id)
				syori_index_lineHead( syori_count ) = index_lineHead
				syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(line[ \t]*.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
				syori_delete_len( syori_count ) = 0
				syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
				syori_count++
			}
			//オブジェクト調査(pos,size)
			matches result, oneLineScript_buf_after_textReplacedDummy, "^(line)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;パラメータが全省略されている
			_result = ""
			if stat = 0 {
				matches result, oneLineScript_buf_after_textReplacedDummy, "^(line[ \t]*)(.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1
				if stat = 0 : swbreak
				_result = result(0,2)
			}
			syori_line( syori_count ) = hspLine_(mod.id)
			syori_index_lineHead( syori_count ) = index_lineHead
			syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1)
			syori_delete_len( syori_count ) = strlen._result
			write_atama = "" : if result(0,1) = "line" : write_atama = " " ;「line」だけでパラメータ全省略のときもある。新たに書き足されるパラメータの間に空白を入れる。
			switch opt3_( mod.id )
				case 0 : syori_write( syori_count ) = write_atama + ( pos_x2_(mod.id)                    )+", "+( pos_y2_(mod.id)                    )+", "+( pos_x2_(mod.id) + size_w2_(mod.id) )+", "+( pos_y2_(mod.id) + size_h2_(mod.id) ) : swbreak
				case 1 : syori_write( syori_count ) = write_atama + ( pos_x2_(mod.id) + size_w2_(mod.id) )+", "+( pos_y2_(mod.id) + size_h2_(mod.id) )+", "+( pos_x2_(mod.id)                    )+", "+( pos_y2_(mod.id)                    ) : swbreak
				case 2 : syori_write( syori_count ) = write_atama + ( pos_x2_(mod.id)                    )+", "+( pos_y2_(mod.id) + size_h2_(mod.id) )+", "+( pos_x2_(mod.id) + size_w2_(mod.id) )+", "+( pos_y2_(mod.id)                    ) : swbreak
				default: syori_write( syori_count ) = write_atama + ( pos_x2_(mod.id) + size_w2_(mod.id) )+", "+( pos_y2_(mod.id)                    )+", "+( pos_x2_(mod.id)                    )+", "+( pos_y2_(mod.id) + size_h2_(mod.id) ) : swbreak
			swend
			syori_count++
			swbreak
			
		case "circle" 
			//--------------------------------------
			// オブジェクト自身にpos,sizeパラメータがあり、手前や後続に影響を与えない。
			//--------------------------------------
			script_buf_after = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//オブジェクト調査
			matches result, oneLineScript_buf_after_textReplacedDummy, "^(circle)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;パラメータが全省略されている
			_result = ""
			if stat = 0 {
				matches result, oneLineScript_buf_after_textReplacedDummy, "^(circle[ \t]+)(.*?,.*?,.*?,.*?),.*?[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第5パラメータまであるとき
				if stat = 0 {
					matches result, oneLineScript_buf_after_textReplacedDummy, "^(circle[ \t]+)(.*?)(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1
					if stat = 0 : swbreak
				}
				_result = result(0,2)
			}
			syori_line( syori_count ) = hspLine_(mod.id)
			syori_index_lineHead( syori_count ) = index_lineHead
			syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1)
			syori_delete_len( syori_count ) = strlen._result
			write_atama = "" : if result(0,1) = "circle" : write_atama = " " ;「circle」だけでパラメータ全省略のときもある。新たに書き足されるパラメータの間に空白を入れる。
			syori_write( syori_count ) = write_atama + pos_x2_( mod.id )+", "+pos_y2_( mod.id )+", "+( size_w2_(mod.id) + pos_x2_( mod.id ) )+", "+( size_h2_(mod.id) + pos_y2_( mod.id ) )
			syori_count++
			swbreak
			
		case "grect"
			//--------------------------------------
			// オブジェクト自身にpos,sizeパラメータがあり、手前や後続に影響を与えない。
			//--------------------------------------
			script_buf_after = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//オブジェクト調査
			matches result, oneLineScript_buf_after_textReplacedDummy, "^(grect[ \t]+)(.*?,.*?)(,.*?)(,.*?,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第5パラメータまであるとき
			if stat > 0 {
				_result = result(0,2) + result(0,3) + result(0,4),  strmid( script_buf_after, strlen(result(0,1)+result(0,2)), strlen(result(0,3)) ) ;_result(1)は長さだけでなくスクリプトを使いたいのでダミーじゃないscript_buf_afterから拾い直す
			}else {
				matches result, script_buf_after, "^(grect[ \t]+)(.*?,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第4パラメータまであるとき
				if stat > 0 {
					_result = result(0,2) + result(0,3) + result(0,4),  strmid( script_buf_after, strlen(result(0,1)+result(0,2)), strlen(result(0,3)) ) 
				}else {
					matches result, script_buf_after, "^(grect[ \t]+)(.*?,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第3パラメータまであるとき
					if stat > 0 {
						_result = result(0,2) + result(0,3),  strmid( script_buf_after, strlen(result(0,1)+result(0,2)), strlen(result(0,3)) ) 
					}else {
						matches result, script_buf_after, "^(grect[ \t]+)(.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第1か第2パラメータまであるとき
						if stat > 0 {
							_result = result(0,2),  ", "+opt1_( mod.id )
						}else {
							matches result, script_buf_after, "^(grect)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;パラメータが全省略されているとき
							if stat = 0 : swbreak
							_result = "",  ", "+opt1_( mod.id )
						}
					}
				}
			}
			dig = opt1_( mod.id )
			dbl = sin(dig)*sin(dig)-cos(dig)*cos(dig)
			w = size_w1_( mod.id )
			h = size_h1_( mod.id )
			syori_line( syori_count ) = hspLine_(mod.id)
			syori_index_lineHead( syori_count ) = index_lineHead
			syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1)
			syori_delete_len( syori_count ) = strlen._result(0)
			write_atama = "" : if result(0,1) = "grect" : write_atama = " " ;「circle」だけでパラメータ全省略のときもある。新たに書き足されるパラメータの間に空白を入れる。
			syori_write( syori_count ) = write_atama + (pos_x2_( mod.id ) + (w+1)/2)+", "+(pos_y2_( mod.id ) + (h+1)/2)+ _result(1) +", "+(int((cos(dig)*w-sin(dig)*h)/(-dbl)*10+5)/10)+", "+(int((sin(dig)*w-cos(dig)*h)/dbl*10+5)/10)
			syori_count++
			swbreak
			
		case "picload"
			//--------------------------------------
			// サイズ不変。posのみ調査する。
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(picload[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			swbreak
			
		case "chkbox"
			//--------------------------------------
			// pos,size両方とも調査必要
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(chkbox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//objsize調査
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				//index_toFunc前のobjsize調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])objsize[ \t]+)("+size_w0_(mod.id)+"[ \t]*,[ \t]*"+size_h0_(mod.id)+")[ \t]*(?:,|\n|:|;|//|/\\*|\\}|$)", funcnameAffectedSize_objsize_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+size_w2_(mod.id)+", "+size_h2_(mod.id)
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "objsize "+size_w2_(mod.id)+", "+size_h2_(mod.id)
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_write( syori_count ) += " : "
					syori_count++
				}
				//index_toFunc後ろのobjsize調査
				if NeedBackToOriginal_AfterFunc_SubMatch( script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))objsize[ \t]+", funcnameAffectedSize_objsize_, scopeBreakerReg_after_size_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(chkbox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : objsize "+size_w0_(mod.id)+", "+size_h0_(mod.id)
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_count++
				}
			}
			swbreak
			
		case "mesbox"
			//--------------------------------------
			// オブジェクト自身にサイズのパラメータあり。posのみ調査する。
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(mesbox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//オブジェクト調査(size)
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				matches result, oneLineScript_buf_after_textReplacedDummy, "^(mesbox[ \t]+)(.*?)(,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第4パラメータ以上あるとき
				if stat > 0 {
					_result = result(0,3) + result(0,4)
				}else {
					matches result, oneLineScript_buf_after_textReplacedDummy, "^(mesbox[ \t]+)(.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第3パラメータまであるとき
					if stat > 0 {
						_result = result(0,3) + result(0,4)
					}else {
						matches result, oneLineScript_buf_after_textReplacedDummy, "^(mesbox[ \t]+)(.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第2パラメータまであるとき
						if stat > 0 {
							_result = result(0,3)
						}else {
							matches result, oneLineScript_buf_after_textReplacedDummy, "^(mesbox[ \t]+)(.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第1パラメータまであるとき(パラメータ全省略はできない)
							if stat = 0 : swbreak
							_result = ""
						}
					}
				}
				syori_line( syori_count ) = hspLine_(mod.id)
				syori_index_lineHead( syori_count ) = index_lineHead
				syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1) + strlen.result(0,2)
				syori_delete_len( syori_count ) = strlen._result
				syori_write( syori_count ) = ", "+size_w2_( mod.id )+", "+size_h2_( mod.id )
				syori_count++
			}
			swbreak
			
		case "input"
			//--------------------------------------
			// オブジェクト自身にサイズのパラメータあり。posのみ調査する。
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(input[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//オブジェクト調査(size)
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				matches result, oneLineScript_buf_after_textReplacedDummy, "^(input[ \t]+)(.*?)(,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第4パラメータまであるとき
				if stat > 0 {
					_result = result(0,3) + result(0,4)
				}else {
					matches result, oneLineScript_buf_after_textReplacedDummy, "^(input[ \t]+)(.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第3パラメータまであるとき
					if stat > 0 {
						_result = result(0,3) + result(0,4)
					}else {
						matches result, oneLineScript_buf_after_textReplacedDummy, "^(input[ \t]+)(.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第2パラメータまであるとき
						if stat > 0 {
							_result = result(0,3)
						}else {
							matches result, oneLineScript_buf_after_textReplacedDummy, "^(input[ \t]+)(.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第1パラメータまであるとき(パラメータ全省略はできない)
							if stat = 0 : swbreak
							_result = ""
						}
					}
				}
				syori_line( syori_count ) = hspLine_(mod.id)
				syori_index_lineHead( syori_count ) = index_lineHead
				syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1) + strlen.result(0,2)
				syori_delete_len( syori_count ) = strlen._result
				syori_write( syori_count ) = ", "+size_w2_( mod.id )+", "+size_h2_( mod.id )
				syori_count++
			}
			swbreak
			
		case "combox"
			//--------------------------------------
			// pos,size両方とも調査必要
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(combox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//objsize調査
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				//index_toFunc前のobjsize調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])objsize[ \t]+)("+size_w0_(mod.id)+"[ \t]*,[ \t]*"+size_h0_(mod.id)+")(?:[ \t]*\\,|\n|:|;|//|/\\*|\\}|$)", funcnameAffectedSize_objsize_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+size_w2_(mod.id)+", "+size_h2_(mod.id)
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "objsize "+size_w2_(mod.id)+", "+size_h2_(mod.id)
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_write( syori_count ) += " : "
					syori_count++
				}
				//index_toFunc後ろのobjsize調査
				if NeedBackToOriginal_AfterFunc_SubMatch( script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))objsize[ \t]+", funcnameAffectedSize_objsize_, scopeBreakerReg_after_size_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(combox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : objsize "+size_w0_(mod.id)+", "+size_h0_(mod.id)
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_count++
				}
			}
			swbreak
			
		case "listbox"
			//--------------------------------------
			// pos,size両方とも調査必要
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(listbox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//objsize調査
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				//index_toFunc前のobjsize調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])objsize[ \t]+)("+size_w0_(mod.id)+"[ \t]*,[ \t]*"+(size_h0_(mod.id) - opt2_(mod.id))+")[ \t]*(?:,|\n|:|;|//|/\\*|\\}|$)", funcnameAffectedSize_objsize_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+size_w2_(mod.id)+", "+(size_h2_(mod.id) - opt2_(mod.id) + 10) ;+10調整 :ぴったりにすると何故か1行減ることがあるので余分を設けた(環境に寄るかも)。それでもどうしても表示できない行数もある。何故・・・
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "objsize "+size_w2_(mod.id)+", "+(size_h2_(mod.id) - opt2_(mod.id) +10) ;+10調整
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_write( syori_count ) += " : "
					syori_count++
				}
				//index_toFunc後ろのobjsize調査
				if NeedBackToOriginal_AfterFunc_SubMatch( script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))objsize[ \t]+", funcnameAffectedSize_objsize_, scopeBreakerReg_after_size_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(listbox[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : objsize "+size_w0_(mod.id)+", "+(size_h0_(mod.id) - opt2_(mod.id))
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_count++
				}
			}
			swbreak
			
		case "winobj"
			//--------------------------------------
			// オブジェクト自身にサイズのパラメータあり。posのみ調査する。
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(winobj[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//オブジェクト調査(size)
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				matches result, oneLineScript_buf_after_textReplacedDummy, "^(winobj[ \t]+)(.*?,.*?)(,.*?)(,.*?)(,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第7パラメータ以上あるとき
				if stat > 0 {
					result(0,2) += result(0,3) + result(0,4)
					_result = result(0,5) + result(0,6)
				}else {
					matches result, oneLineScript_buf_after_textReplacedDummy, "^(winobj[ \t]+)(.*?,.*?)(,.*?)(,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第6パラメータまであるとき
					if stat > 0 {
						result(0,2) += result(0,3) + result(0,4)
						_result = result(0,5) + result(0,6)
					}else {
						matches result, oneLineScript_buf_after_textReplacedDummy, "^(winobj[ \t]+)(.*?,.*?)(,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第5パラメータまであるとき
						if stat > 0 {
							result(0,2) += result(0,3) + result(0,4)
							_result = result(0,5)
						}else {
							matches result, oneLineScript_buf_after_textReplacedDummy, "^(winobj[ \t]+)(.*?,.*?)(,.*?)(,.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)", 0, 1, 1 ;第4パラメータまであるとき(第3以下からの処理はウィンドウスタイルが0になりどうせ表示されず触れないので不要)
							if stat = 0 : swbreak
							result(0,2) += result(0,3) + result(0,4)
							_result = ""
						}
					}
				}
				syori_line( syori_count ) = hspLine_(mod.id)
				syori_index_lineHead( syori_count ) = index_lineHead
				syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.result(0,1) + strlen.result(0,2)
				syori_delete_len( syori_count ) = strlen._result
				syori_write( syori_count ) = ", "+size_w2_( mod.id )+", "+size_h2_( mod.id )
				syori_count++
			}
			swbreak
			
		case "button"
			//--------------------------------------
			// pos,size両方とも調査必要
			//--------------------------------------
			script_buf_before = strmid( fullScript_buf, 0, index_toFunc )
			script_buf_after  = strmid( fullScript_buf, index_toFunc, INT_MAX )
			oneLineScript_buf_after_textReplacedDummy = GetOneLineScript_TextReplacedDummy( script_buf_after )
			//pos調査
			if pos_x0_( mod.id ) ! pos_x2_( mod.id ) || pos_y0_( mod.id ) ! pos_y2_( mod.id ) {
				//index_toFunc前のpos調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])pos[ \t]+)("+pos_x0_(mod.id)+"[ \t]*,[ \t]*"+pos_y0_(mod.id)+")", funcnameChangesCurrent_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+pos_x2_( mod.id )+", "+pos_y2_( mod.id )
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "pos "+pos_x2_( mod.id )+", "+pos_y2_( mod.id )+" : "
					syori_count++
				}
				//index_toFunc後ろのpos調査
				if NeedBackToOriginal_AfterFunc_SubMatch(  script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))pos[ \t]+", funcnameChangesCurrent_, scopeBreakerReg_after_pos_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(button(?:[ \t]+(?:goto|gosub))?[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : pos "+objed_cx_( mod.id )+", "+objed_cy_( mod.id )
					syori_count++
				}
			}
			//objsize調査
			if size_w0_( mod.id ) ! size_w2_( mod.id ) || size_h0_( mod.id ) ! size_h2_( mod.id ) {
				//index_toFunc前のobjsize調査
				GetData_BeforeFunc_SubMatch lineNum_before, indexLineHead_before, indexSubMatch1_before, lenSubMatch2_before,   script_buf_before, "^((?:.|\n)*(?:\n|:|\\{|[ \t])objsize[ \t]+)("+size_w0_(mod.id)+"[ \t]*,[ \t]*"+size_h0_(mod.id)+")[ \t]*(?:,|\n|:|;|//|/\\*|\\}|$)", funcnameAffectedSize_objsize_, scopeBreakerReg_before_
				if stat ! 0 {
					syori_line( syori_count ) = lineNum_before
					syori_index_lineHead( syori_count ) = indexLineHead_before
					syori_index_fromLineHead( syori_count ) = indexSubMatch1_before - indexLineHead_before
					syori_delete_len( syori_count ) = lenSubMatch2_before
					syori_write( syori_count ) = ""+size_w2_(mod.id)+", "+size_h2_(mod.id)
					syori_count++
				}else {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = "objsize "+size_w2_(mod.id)+", "+size_h2_(mod.id)
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_write( syori_count ) += " : "
					syori_count++
				}
				//index_toFunc後ろのobjsize調査
				if NeedBackToOriginal_AfterFunc_SubMatch( script_buf_after, "^((?:.|\n)*?(?:\n|:|\\{|[ \t]))objsize[ \t]+", funcnameAffectedSize_objsize_, scopeBreakerReg_after_size_ ) {
					syori_line( syori_count ) = hspLine_(mod.id)
					syori_index_lineHead( syori_count ) = index_lineHead
					syori_index_fromLineHead( syori_count ) = index_toFunc - index_lineHead + strlen.submatch( oneLineScript_buf_after_textReplacedDummy, "^(button(?:[ \t]+(?:goto|gosub))?[ \t]+.*?)[ \t]*(?:\n|:|;|//|/\\*|\\}|$)" )
					syori_delete_len( syori_count ) = 0
					syori_write( syori_count ) = " : objsize "+size_w0_(mod.id)+", "+size_h0_(mod.id)
					if objsz_py_( mod.id ) ! 0 : syori_write( syori_count ) += ", "+objsz_py_( mod.id )
					syori_count++
				}
			}
			swbreak
			
		default ; 標準命令になかったら拡張を探る
			//--------------------------------------
			// EXP拡張
			//======================================
			// *label_RewriteScript (エディタ書き換え処理を登録するラベル)
			//--------------------------------------
			foreach objExp
				if objType_(mod.id) = objType_@ObjPosModExpClass( objExp.cnt ) : label_RewriteScript_@ObjPosModExpClass objExp.cnt : gosub refLabel@ObjPosModExpClass : break
			loop
	swend
	
	//--------------------------------------
	// 処理配列を実行 (一番行数が若い順から拾っていき、同じ行だったら一緒に処理してmaeScript、atoScriptに書き込んでいく)
	//======================================
	// MODE_OverwriteHsed_ == 1 :エディタのスクリプトも一緒に書き換えていく
	//--------------------------------------
	;行の若い順にソートするための配列を作る
	Get_syoriSortNums syori_sortedNums, syori_line, syori_index_fromLineHead, syori_count
	;maeScript、atoScript を作っていく
	Set_maeScript_ mod.id, strf("【ID: %d / タイプ: %s】\n\n", modID_( mod.id ), objType_(mod.id) )
	Set_atoScript_ mod.id, strf("【ID: %d / タイプ: %s】\n\n", modID_( mod.id ), objType_(mod.id) )
	line_num = -1
	oneLineScript = ""
	if MODE_OverwriteHsed_ {
		hsow_openTabFilename = ""
		hsow_openTabFootyID = -1
		hsow_caretLine = 0
		hsow_caretPos = 0
		hsow_overwriteCompleted = 1
	}
	repeat syori_count 
		cn = syori_sortedNums(cnt)
		if line_num ! syori_line( cn ) {
			line_num = syori_line( cn )
			;atoScriptためにoneLineScriptに1行取り出しておく(oneLineScriptは複数処理またいで使用されることがある)
			getstr oneLineScript, fullScript_buf, syori_index_lineHead( cn ), , INT_MAX
			oriLen_oneLineScript = strlen.oneLineScript
			//--------------------------------------
			// Set_maeScript_ (maeScriptは、着目行が変わった最初だけ書き込む)
			//--------------------------------------
			Set_maeScript_ mod.id, maeScript_( mod.id ) + strf( "%4d", syori_line( cn ) ) + " ： " + strtrim(oneLineScript,1,'\t') + "\n\n"
			zure = 0 ;syori_index_fromLineHeadは変更前を基準としたindexなので、処理後のズレを補正する変数を用意する
		}
		
		//------------------------------------------------------------------------------
		// MODE_OverwriteHsed_ == 1 ここで一緒にスクリプトエディタの書き換え処理をする
		//------------------------------------------------------------------------------
		if MODE_OverwriteHsed_ {
			repeat 1
			hsow_temp1 = strmid( oneLineScript, 0, syori_index_fromLineHead( cn ) + zure + syori_delete_len( cn ) )
			hsow_temp2 = strmid( oneLineScript, syori_index_fromLineHead( cn ) + zure, syori_delete_len( cn ) )
			hsow_temp3 = syori_write( cn )
			
			;処理するタブを見ていないなら切り替える
			if hsow_openTabFilename ! hspFile_( mod.id ) {
				if hspFile_( mod.id ) = "???" { ;もし無題ならhsptmp_スクリプトと同じ中身のタブを表示させる
					HSED_ShowTab_script@ObjPosModHsedModule hsptmp_
				}else {
					hspFilePath = Get_fullPath_@ObjPosModScriptClass( hspFile_( mod.id ) )
					HSED_ShowTab_filename@ObjPosModHsedModule hspFilePath
				}
				if stat = -1 : hsow_openTabFilename = "" : hsow_openTabFootyID = -1 : hsow_overwriteCompleted = 0 : break ;タブを開けなかった
				hsow_openTabFilename = hspFile_( mod.id )
				hsow_openTabFootyID = stat
				hsow_caretLine = 0
				hsow_caretPos = 0
				HSED_SetForeground@ObjPosModHsedModule ;スクリプトエディタをアクティブ化
			}
			;注目する行が違うならキャレットを移動させる
			if hsow_caretLine ! line_num {
				HSED_SetCaretLine@ObjPosModHsedModule hsow_openTabFootyID, line_num
				if stat ! 0 : hsow_caretLine = 0 : hsow_caretPos = 0 : hsow_overwriteCompleted = 0 : break ;キャレットを移動できなかった
				hsow_caretLine = line_num
				hsow_caretPos = 0
			}
			;右に移動
			rmove = StringToWordCount( hsow_temp1 )
			HSED_MoveCaretRight@ObjPosModHsedModule hsow_openTabFootyID, rmove - hsow_caretPos ;移動済みの場合はその分間引く
			;BackSpaceで消す
			bmove = StringToWordCount( hsow_temp2 )
			HSED_PressBackspaceKey@ObjPosModHsedModule hsow_openTabFootyID, bmove
			;書き込む
			hsed_sendstr hsow_temp3
			hsow_caretPos = rmove - bmove + StringToWordCount( hsow_temp3 )
			;//書き換え完了 (修正済みマークと次に向けて初期値を修正する)
			Set_hasBeenFixed_ mod.id, 1
			Set_pos_xy0_ mod.id, pos_x2_(mod.id), pos_y2_(mod.id)
			Set_pos_xy1_ mod.id, pos_x2_(mod.id), pos_y2_(mod.id)
			Set_size_wh0_ mod.id, size_w2_(mod.id), size_h2_(mod.id)
			Set_size_wh1_ mod.id, size_w2_(mod.id), size_h2_(mod.id)
			loop
		}
		//------------------------------------------------------------------------------
		// End of MODE_OverwriteHsed_ == 1 ここで一緒にスクリプトエディタの書き換え処理をする
		//------------------------------------------------------------------------------

		;atoScript用にoneLineScriptを編集して書き換えていく
		oneLineScript = strmid( oneLineScript, 0, syori_index_fromLineHead( cn ) + zure )  +  syori_write( cn )  +  strmid( oneLineScript, syori_index_fromLineHead( cn ) + zure + syori_delete_len( cn ), INT_MAX )
		zure += strlen.syori_write( cn ) - syori_delete_len( cn )
		//--------------------------------------
		// Set_atoScript_ (同一着目行がある場合はその行のすべての処理が施された後に書き込む必要があるので、着目行が変わる手前(またはループの最後)で書き込む)
		//--------------------------------------
		flg = 0 : if cnt < syori_count-1 { if syori_line( syori_sortedNums(cnt+1) ) ! line_num { flg = 1 } } else : flg = 1
		if flg = 1 {
			Set_atoScript_ mod.id, atoScript_( mod.id ) + strf( "%4d", syori_line( cn ) ) + " ： " + strtrim(oneLineScript,1,'\t') + "\n\n"
			;ついでにfullScript_bufの書き換えと以降のsyori_index_lineHeadの更新もしておく
			fullScript_buf = strmid( fullScript_buf, 0, syori_index_lineHead( cn ) ) + oneLineScript + strmid( fullScript_buf, syori_index_lineHead( cn ) + oriLen_oneLineScript, INT_MAX )
			repeat syori_count - (cnt+1), cnt+1
				syori_index_lineHead( cnt ) += strlen.oneLineScript - oriLen_oneLineScript
			loop
		}
	loop

	if MODE_OverwriteHsed_ {
		//保持しているスクリプトを書き換えたものに更新する
		if hsow_overwriteCompleted = 1 : Set_fullScript_ mod.id, fullScript_buf
	}
	return
	
//------------------------------------------------------------------------------
// モジュール内で使用しているサブルーチン
//------------------------------------------------------------------------------
//--------------------------------------
// 指定した命令(_objType)までのindexを返す
//--------------------------------------
#deffunc local GetIndex_toFuncAndLineHead var out_index_toFunc, var out_index_lineHead, var script, int gyo, str _objType, \
local index, \
local word, \
local result, \
local i
	out_index_toFunc = -1
	out_index_lineHead = -1
	if gyo =  0 : return
	index = 0
	repeat gyo
		getstr word, script, index, ,INT_MAX : index += strsize
	loop
	strsize_ = strsize
	if _objType ! "" {
		matches result, word, "^(.*?(?::|\\{|[ \t]|\n|^))"+_objType+"(?:[ \t]|\n|:|;|//|/\\*|\\}|$)", 0, 1, 1
		if stat = 0 : return
		out_index_toFunc = index - strsize_ + strlen.result(0,1)
	}
	out_index_lineHead = index - strsize_
	;_objType == "" のときは、out_index_toFunc==-1, out_index_lineHead==指定Line行頭index が返る
	return
//--------------------------------------
// テキストやコメントアウトを全てダミー文字に置き換える。先頭1行しか見ない。(index_toFunc直後のオブジェクトのパラメータを調査する箇所のみで使用。スクリプト全文に適用すると重すぎた)
//--------------------------------------
#defcfunc local GetOneLineScript_TextReplacedDummy var script, \
local temp, \
local result, \
local len
	getstr temp, script, 0, ,INT_MAX
	minRes1 = ""
	repeat
		len_minRes1 = INT_MAX ;テキストやコメントアウトの出てくるのが早い順に抽出
		matches result, temp, "^((?:.|\n)*?)(\".*?[^\\\\]\")",			0, 1, 1	: if stat ! 0 : len = strlen.result(0,1) : if len < len_minRes1 : len_minRes1 = len : len_minRes2 = strlen.result(0,2)
		matches result, temp, "^((?:.|\n)*?)(//.*?\n)",					0, 1, 1	: if stat ! 0 : len = strlen.result(0,1) : if len < len_minRes1 : len_minRes1 = len : len_minRes2 = strlen.result(0,2)
		matches result, temp, "^((?:.|\n)*?)(;.*?\n)",					0, 1, 1	: if stat ! 0 : len = strlen.result(0,1) : if len < len_minRes1 : len_minRes1 = len : len_minRes2 = strlen.result(0,2)
		matches result, temp, "^((?:.|\n)*?)(/\\*(?:.|\n)*?\\*/)",		0, 1, 1	: if stat ! 0 : len = strlen.result(0,1) : if len < len_minRes1 : len_minRes1 = len : len_minRes2 = strlen.result(0,2)
		matches result, temp, "^((?:.|\n)*?)(\\{\"(?:.|\n)*?\"\\})",	0, 1, 1	: if stat ! 0 : len = strlen.result(0,1) : if len < len_minRes1 : len_minRes1 = len : len_minRes2 = strlen.result(0,2)
		if len_minRes1 = INT_MAX : break
		memset temp, 'X', len_minRes2, len_minRes1 ;抽出した長さ分ダミー文字'X'で置き換える
	loop
	return temp
//--------------------------------------
// pos(size)位置を特定するためのmatchテキストから各種データを取得
//--------------------------------------
#deffunc local GetData_BeforeFunc_SubMatch var out_lineNum, var out_indexLineHead, var out_indexSubMatch1, var out_lenSubMatch2,  var script, str matchText, array funcnameJammer, array scopeBreakerReg, \
local result, \
local i
	matched = 1
	matches result, script, matchText, 0,1,1
	if stat = 1 {
		out_indexSubMatch1 = strlen.result( 0, 1 ) ;行頭からmesに一番近いposのパラメータ頭までの文字列長
		out_lenSubMatch2 = strlen.result( 0, 2 )   ;位置x,yパラメータの文字列長
		GetLastLineAndIndex out_lineNum, out_indexLineHead, result( 0, 1 ) ;result(=posのパラメータ頭までのスクリプト)の最終行数と最終行頭のindexを調べて記憶
		result = strmid( script, out_indexSubMatch1 + out_lenSubMatch2, INT_MAX ) ;resultにposとmesまでの間のスクリプト代入。↓で、間にカレントポジションが変わる命令等の邪魔者がいないか確認する。
	}else {
		matched = 0 ;ダメ
	}
	;間に邪魔者(命令またはカレントスコープが外れる記述)がいればそのposでは指定できない。命令の直前に新規で加える形になる。
	if matched = 1 {
		foreach funcnameJammer
			if match( result, "(\n|:|\\{|[ \t])"+funcnameJammer.cnt+"[ \t]", 0, 1 ) ! "" : matched = 0 : break ;ダメ
		loop
	}
	if matched = 1 {
		foreach scopeBreakerReg
			if match( result, scopeBreakerReg.cnt, 0, 1 ) ! "" : matched = 0 : break ;ダメ
		loop
	}
	return matched
//--------------------------------------
// オブジェクト後からmatchテキストまでの間にカレントポジション(またはobjsize)を戻す必要があるか
//--------------------------------------
#defcfunc local NeedBackToOriginal_AfterFunc_SubMatch  var script, str matchText, array funcnameJammer, array scopeBreakerReg, \
local result, \
local _result
	need = 0
	result = submatch( script, matchText, 0, 1 )
	if result = "" : result = script ;matchしなくてもスクリプトの最後までカレントポジション(またはobjsize)が使われない(funcnameJammer.cntが無い)のであればカレントを戻す処理はいらない。
	;間に邪魔者がいればmatchTextの前にカレント戻しが必要となる箇所がある。命令の直後にカレントを元に戻す処理を入れる。
	if need = 0 {
		foreach funcnameJammer
			_result = match( result, "^(?:.|\n)*?(\n|:|\\{|[ \t])"+funcnameJammer.cnt+"[ \t]*?.*?(?:\n|:|;|//|/\\*|\\}|$)", 0, 1 )
			if _result ! "" : result = _result  : need = 1 ;必要  //breakせず、すべて繰り返せば一番近い邪魔者が得られる
		loop
	}
	;逆にその邪魔者との間でカレントのスコープが外れるときはカレント戻し処理はいらなくなるはず
	if need = 1 && result ! "" {
		repeat length.scopeBreakerReg
			if match( result, scopeBreakerReg.cnt, 0, 1 ) ! "" : need = 0 : break ;必要じゃない
		loop
	}
	return need
//--------------------------------------
// 最終の行数と行頭のindexを変数に入れる
//--------------------------------------
#deffunc local GetLastLineAndIndex var out_line, var out_index, var script, \
local len, \
local word
	out_line = 0
	out_index = 0
	len = strlen.script : if len = 0 : return
	out_line = 1
	repeat
		getstr word, script, out_index, ,INT_MAX
		if out_index + strsize >= len : break
		out_index += strsize
		out_line++
	loop
	return
//--------------------------------------
// 行と行からのindexを見て若い順にソートして配列を返す
//--------------------------------------
#deffunc local Get_syoriSortNums array out_sortNums, array _syori_line, array _syori_index, int _syori_count, \
local i, \
local min, \
local len
	dim out_sortNums, _syori_count
	dim sorted, _syori_count
	i = 0
	repeat _syori_count
		min = INT_MAX
		repeat _syori_count
			if sorted( cnt ) = 1 : continue
			len = _syori_line( cnt )*10000 + _syori_index( cnt )
			if min >= len : min = len : i = cnt
		loop
		out_sortNums( cnt ) = i : sorted( i ) = 1
	loop
	return
//--------------------------------------
// 文字列が何文字か返す(Shift_JIS)
//--------------------------------------
#defcfunc local StringToWordCount str script, \
local index, \
local word, \
local i, \
local len
	word = script
	len = strlen(word)
	if len = 0 : return 0
	index = 0
	repeat ,1
		i = peek( word, index )
		if ( 129<=i && i<=159 ) || ( 224<=i && i<=252 ) : index++
		index++
		if index >= len : len = cnt : break
	loop
	return len
//------------------------------------------------------------------------------
// End of モジュール内で使用しているサブルーチン
//------------------------------------------------------------------------------

#global
//------------------------------------------------------------------------------
// End of オブジェクトのクラス(モジュール型変数)
//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿



//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣
// スクリプトエディタ操作用モジュール (要#include "hsedsdk.as")
//------------------------------------------------------------------------------
#include "hsedsdk.as"

#module ObjPosModHsedModule
//--------------------------------------
// 関数定義(API関数)
//--------------------------------------
#uselib "user32"
#func SetForegroundWindow "SetForegroundWindow" int
//--------------------------------------
// 記号定数(API関数)
//--------------------------------------
#const TCM_FIRST       $1300
#const TCM_SETCURFOCUS (TCM_FIRST + 48)
#const VK_BACK         $08
#const VK_RIGHT        $27

//--------------------------------------
// 指定したスクリプトと同じ内容のタブを探しファイル名を取得
//--------------------------------------
#defcfunc local HSED_GetFilename var script
	_script = strtrim_EndReturn( script ) ;hsp3.51とhsp3.6とでhsptmp末尾の改行の扱いが違ったのでどちらでも対応できるよう除去して比較する
	refs = ""
	hsed_gettabcount nTabs
	if stat : return refs
	repeat nTabs
		hsed_getpath path, cnt
		if stat ! 0 : continue
		hsed_getfootyid idFooty, cnt
		hsed_gettext hs_buf, idFooty
		if strtrim_EndReturn( hs_buf ) = _script : refs = path : break
	loop
	sdim hs_buf,1
	return refs
//末尾の改行コードを除去
#defcfunc local strtrim_EndReturn var script, local index, local temp
	temp = script : index = strlen.temp
	repeat
		index -= 2 : if index < 0 : break
		if wpeek(temp, index) = 2573 : poke temp, index, 0 : else : break ;改行コードなら終端コード書き込み、違ったら終了 
	loop
	return temp
//--------------------------------------
// ファイルをスクリプトエディタで開いているかどうかを取得
//--------------------------------------
#defcfunc local HSED_IsOpenedFile str filename
	st = 0
	hsed_gettabcount nTabs
	if stat : return st
	repeat nTabs
		hsed_getpath path, cnt
		if stat ! 0 : continue
		if path = filename : st = 1 : break
	loop
	return st
//--------------------------------------
// 指定したファイル名のタブを探しスクリプトを取得
//--------------------------------------
#defcfunc local HSED_GetScript str filename
	refs = ""
	hsed_gettabcount nTabs
	if stat : return refs
	repeat nTabs
		hsed_getpath path, cnt
		if stat ! 0 : continue
		if path = filename {
			hsed_getfootyid idFooty, cnt
			hsed_gettext refs, idFooty
			break
		}
	loop
	return refs
//--------------------------------------
// 指定したファイル名のタブを探して表示させる
//--------------------------------------
#deffunc local HSED_ShowTab_filename str filename
	st = -1
	hsed_gettabcount nTabs
	if stat : return st
	repeat nTabs
		hsed_getpath path, cnt
		if stat ! 0 : continue
		if path = filename {
			hsed_getwnd hwndHsedTab, HGW_TAB
			sendmsg hwndHsedTab, TCM_SETCURFOCUS, cnt, 0
			hsed_getfootyid idFooty, cnt
			st = idFooty
			break
		}
	loop
	return st
//--------------------------------------
// 指定したスクリプトと同じ内容のタブを探して表示させる
//--------------------------------------
#deffunc local HSED_ShowTab_script var script
	_script = strtrim_EndReturn( script ) ;hsp3.51とhsp3.6とでhsptmp末尾の改行の扱いが違ったので除去して比較する
	st = -1
	hsed_gettabcount nTabs
	if stat : return st
	repeat nTabs
		hsed_getfootyid idFooty, cnt
		hsed_gettext hs_buf, idFooty
		if strtrim_EndReturn( hs_buf ) = _script {
			hsed_getwnd hwndHsedTab, HGW_TAB
			sendmsg hwndHsedTab, TCM_SETCURFOCUS, cnt, 0
			st = idFooty
			break
		}
	loop
	return st
//--------------------------------------
// 指定した行番号(の先頭)にキャレットの位置を変更
//--------------------------------------
#deffunc local HSED_SetCaretLine int nFootyID, int nLine
	hsed_capture
	if stat : return 1
	if nLine < 1 : return 1
	sendmsg hIF@hsedsdk, _HSED_SETCARETLINE@hsedsdk, nFootyID, nLine - 1
	return
//--------------------------------------
// スクリプトエディタをアクティブにする
//--------------------------------------
#deffunc local HSED_SetForeground
	hsed_getwnd hsedHwnd, 0
	SetForegroundWindow hsedHwnd
	return
//--------------------------------------
// スクリプトエディタのキャレットを指定文字数ぶん右に移動させる
//--------------------------------------
#deffunc local HSED_MoveCaretRight int nFootyID, int i
	hsed_getwnd hwndHsedFooty, HGW_EDIT, nFootyID
	repeat i
		keybd_send hwndHsedFooty, VK_RIGHT, 0
		keybd_send hwndHsedFooty, VK_RIGHT, 1
	loop
	return
//--------------------------------------
// スクリプトエディタにバックスペースのコードを送信して指定文字数ぶん消す
//--------------------------------------
#deffunc local HSED_PressBackspaceKey int nFootyID, int i
	hsed_getwnd hwndHsedFooty, HGW_EDIT, nFootyID
	repeat i
		keybd_send hwndHsedFooty, VK_BACK, 0
		keybd_send hwndHsedFooty, VK_BACK, 1
	loop
	return
//--------------------------------------
// SendMessageによるキーコード送信 (by MillkeyStars様)
//======================================
// 指定されたウィンドウハンドルへキーコードを送信します。
// Keybd_Send p1,p2,p3
// p1 = 送る先のウィンドウハンドル
// p2 = 仮想キーコード
// p3 = 押す/離す フラグ
// http://hsptv.sakura.ne.jp/play/pforum.php?mode=pastwch&num=57862
//--------------------------------------
#uselib "user32.dll"
#cfunc MapVirtualKey "MapVirtualKeyA" sptr,sptr
#define WM_KEYDOWN	0x0100
#define WM_KEYUP	0x0101
#deffunc local Keybd_Send int WindowHandle,int KeyVirtualCode,int Mode
	wVk = KeyVirtualCode
	wScan = MapVirtualKey(wVk,0)
	Put_lparam = 0
	
	//共通用
	Put_lparam |= 1 << 0		//リピートカウント(0-15ビット)
	Put_lparam |= wScan << 16	//スキャンコード(16-23ビット)

	if ( Mode = 0){
		//WM_KEYDOWN用
		Put_lparam |= 0 << 24		//拡張キー(24ビットのみ)
	//	Put_lparam |= 0 << 25		//使われていません。	
		Put_lparam |= 0 << 29		//コンテキストコード(29ビットのみ)
		Put_lparam |= 0 << 30		//ボタンが通常か長押しか(30ビットのみ)
		Put_lparam |= 0 << 31		//変換タイプ(31ビットのみ)
		sendmsg WindowHandle,WM_KEYDOWN,wVk,Put_lparam  ;PostMessageから変更
	} else {
		//WM_KEYUP用
		Put_lparam |= 0 << 24		//拡張キー(24ビットのみ)
	//	Put_lparam |= 0 << 25		//使われていません。	
		Put_lparam |= 0 << 29		//コンテキストコード(29ビットのみ)
		Put_lparam |= 1 << 30		//ボタンが通常か長押しか(30ビットのみ)
		Put_lparam |= 1 << 31		//変換タイプ(31ビットのみ)
		sendmsg WindowHandle,WM_KEYUP,wVk,Put_lparam  ;PostMessageから変更
	}
return

#global
//------------------------------------------------------------------------------
// End of スクリプトエディタ操作用の命令 (要#include "hsedsdk.as")
//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿


//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣
// ObjPosMod モジュール本体
//------------------------------------------------------------------------------
#module ObjPosMod

//--------------------------------------
// 関数定義(API関数)
//--------------------------------------
#uselib "user32"
#func CallNextHookEx "CallNextHookEx" sptr,sptr,sptr,sptr
#func ChildWindowFromPoint "ChildWindowFromPoint" int,int,int
#func ClientToScreen "ClientToScreen" int, int
#func EnableWindow "EnableWindow" int,int
#func GetClassName "GetClassNameA" int,int,int
#func GetParent "GetParent" int
#func GetWindowLong "GetWindowLongA" int,int
#func GetWindowRect "GetWindowRect" int,int
#func GetWindowThreadProcessId "GetWindowThreadProcessId" sptr,sptr
#func InvalidateRect "InvalidateRect" int,int,int
#func IsWindowVisible "IsWindowVisible" int
#func MoveWindow "MoveWindow" int,int,int,int,int,int
#func ScreenToClient "ScreenToClient" int, int
#func SetForegroundWindow "SetForegroundWindow" int
#func SetLayeredWindowAttributes "SetLayeredWindowAttributes" int,int,int,int
#func SetParent "SetParent" sptr,sptr
#func SetWindowLong "SetWindowLongA" int,int,int
#func SetWindowPos "SetWindowPos" int,int,int,int,int,int,int
#func SetWindowsHookEx "SetWindowsHookExA" sptr,sptr,sptr,sptr
#func ShowWindow "ShowWindow" int,int
#func UnhookWindowsHookEx "UnhookWindowsHookEx" sptr
#func UpdateWindow "UpdateWindow" int
#func WindowFromPoint "WindowFromPoint" int,int
#uselib "gdi32"
#func GetStockObject "GetStockObject" int

//--------------------------------------
// 記号定数(API関数)
//--------------------------------------
#const BM_SETCHECK                  $000000F1 
#const BM_SETSTYLE                  $000000F4

#const BS_AUTOCHECKBOX              $00000003

#const CDDS_ITEMPREPAINT            $00010001
#const CDDS_PREPAINT                $00000001

#const CDRF_NOTIFYITEMDRAW          $00000020

#const GWL_EXSTYLE                  $FFFFFFEC
#const GWL_HWNDPARENT               $FFFFFFF8
#const GWL_STYLE                    $FFFFFFF0

#const LVM_DELETEITEM               $00001008
#const LVM_GETITEM                  $00001005
#const LVM_GETITEMCOUNT             $00001004
#const LVM_GETNEXTITEM              $0000100C
#const LVM_INSERTCOLUMN             $0000101B
#const LVM_INSERTITEMA              $00001007
#const LVM_SETEXTENDEDLISTVIEWSTYLE $00001036
#const LVM_SETITEMA                 $00001006

#const LVNI_ALL                     $00000000
#const LVNI_FOCUSED                 $00000001
#const LVNI_SELECTED                $00000002

#const LVS_EX_FULLROWSELECT         $00000020

#const LWA_ALPHA                    $00000002
#const LWA_COLORKEY                 $00000001

#const SPI_GETWORKAREA              $00000030

#const SWP_HIDEWINDOW               $00000080
#const SWP_NOACTIVATE               $00000010
#const SWP_NOMOVE                   $00000002
#const SWP_NOOWNERZORDER            $00000200
#const SWP_NOSIZE                   $00000001
#const SWP_NOZORDER                 $00000004
#const SWP_SHOWWINDOW               $00000040

#const WM_APP                       $00008000
#const WM_CONTEXTMENU               $0000007B
#const WM_GETTEXT                   $0000000D
#const WM_LBUTTONDOWN               $00000201
#const WM_LBUTTONUP                 $00000202
#const WM_MOUSEMOVE                 $00000200
#const WM_NCLBUTTONUP               $000000A2
#const WM_NCRBUTTONUP               $000000A5
#const WM_NOTIFY                    $0000004E
#const WM_RBUTTONDOWN               $00000204
#const WM_RBUTTONUP                 $00000205
#const WM_SETTEXT                   $0000000C
#const WM_SIZE                      $00000005
#const WM_TIMER                     $00000113

#const WS_CHILD                     $40000000
#const WS_EX_LAYERED                $00080000
#const WS_EX_TRANSPARENT            $00000020
#const WS_MAXIMIZEBOX               $00010000
#const WS_MINIMIZEBOX               $00020000
#const WS_POPUP                     $80000000
#const WS_THICKFRAME                $00040000
#const WS_VISIBLE                   $10000000

#const HWND_BOTTOM                  1
#const HWND_TOP                     0
#const HWND_TOPMOST                 -1
#const HWND_NOTOPMOST               -2

#const NM_CLICK                     -2
#const NM_DBLCLK                    -3
#const NM_SETFOCUS                  -7
#const NM_KILLFOCUS                 -8
#const NM_CUSTOMDRAW                -12

#const SW_HIDE                      0
#const SW_SHOWNOACTIVATE            4
#const SW_SHOW                      5

#const WH_MOUSE                     7

//--------------------------------------
// 関数定義
//--------------------------------------
#define ctype TanrakuOR(%1=0,%2=0,%3=0,%4=0,%5=0,%6=0,%7=0,%8=0,%9=0) 1:trkor=(%1):if(trkor=0){ trkor=(%2):if(trkor=0){ trkor=(%3):if(trkor=0){ trkor=(%4):if(trkor=0){ trkor=(%5):if(trkor=0){ trkor=(%6):if(trkor=0){ trkor=(%7):if(trkor=0){ trkor=(%8):if(trkor=0){ trkor=(%9) }}}}}}}}:if(trkor!0)
; if TanrakuOR() :それぞれの項目ごとにifして条件を満たした(0以外になった)ら以降の項目は無視して(処理せず)条件式を終わらせる

//--------------------------------------
// 記号定数
//--------------------------------------
#const WIN_TYPE_BUFFER              1
#if __hspver__ <= $3701
	;picloadバグ対応
	#const PL_ALPHABUG_FIX 1
#else
	#const PL_ALPHABUG_FIX 0
#endif

//--------------------------------------
// 変数初期化
//--------------------------------------
#deffunc local varinit
	;hsptmp拾い用にカレントディレクトリを保持しておく
	dirCurrent = dir_cur
	;変数
	widGuids = 0
	hwGuids = 0
	;guidXYWH = 0,0,0,0
	widDots = 0
	hwDots = 0
	bgColorR = 253	;被らなさそうな適当な背景色
	bgColorG = 249	;
	bgColorB = 247	;
	rxi = -1, 0, 1, 1, 1, 0,-1,-1,-2,-1, 0, 1, 2, 2, 2, 2, 2, 1, 0,-1,-2,-2,-2,-2 ;lineクリックの太らせ判定用配列
	ryi = -1,-1,-1, 0, 1, 1, 1, 0,-2,-2,-2,-2,-2,-1, 0, 1, 2, 2, 2, 2, 2, 1, 0, 1 ;
	stockObjects = 0   ;sysfont確認用
	stockObjectIDs = 0 ;
	alignDot = 0
	dotInterval = 5
	alignObj = 1
	wTopMost = 1
	objConnectDiff = 3 ;吸着範囲 (line反転範囲も兼用)
	;選択中のオブジェクトを記憶する配列変数
	InitData selectDataIDs	;初期化
	;モジュール変数の初期化
	newmod objData, ObjPosModDataClass, 0,0,0,0,"",0,0,0,0,0,0,0,0,0,0,"",0
	delmod objData.0
	;汎用
	sdim string256, 256
	dim rect, 4
	return
	
//------------------------------------------------------------------------------
// メインウィンドウの作成や操作関数
//------------------------------------------------------------------------------
//--------------------------------------
// モジュール初期化 + 空きIDの登録 (一番最初のオブジェクト命令のとき割り込んで実行される)
//--------------------------------------
#deffunc local initObjPos_SetBlankWinID int wID

	g_sel = ginfo_sel
	blankWinID = wID

	;// 変更結果を表示するメインウィンドウを作成
	screen blankWinID, ginfo_dispx,ginfo_dispy, 10, ginfo_dispx-710,ginfo_dispy-450, 700,380
	title ""+ _MODULE_NAME_@ObjPosMod +" ver."+ _MODULE_VERSION_@ObjPosMod
	widMain = blankWinID
	hwMain = hwnd
	#define CHILDWINDOW_sizeY 65
	#define CHILDWINDOW_posY ginfo_winy - CHILDWINDOW_sizeY
	#define SCRIPTBOX_sizeY 100
	#define SCRIPTBOX_posY ginfo_winy - CHILDWINDOW_sizeY - SCRIPTBOX_sizeY
	#define SCRIPTBOX_buttonW 100
	#define SCRIPTBOX_buttonH 30
	#define LISTVIEW_sizeY SCRIPTBOX_posY - 5
	#define LISTVIEW_buttonW 60
	#define LISTVIEW_buttonH 20
	createListView ginfo_sx,ginfo_sy, 0,0, ginfo_winx,LISTVIEW_sizeY
	blankWinID++
	;// スクリプトを表示するmesboxを配置する
	pos 0, SCRIPTBOX_posY
	mesbox_maeScript = "変更前のスクリプト"
	mesbox@hsp mesbox_maeScript, (ginfo_winx - (SCRIPTBOX_buttonW+10))/2, SCRIPTBOX_sizeY, 4, 0
	hMesbox_maeScript = objinfo(stat, 2)
	pos (ginfo_winx + (SCRIPTBOX_buttonW+10))/2, SCRIPTBOX_posY
	mesbox_atoScript = "変更後のスクリプト"
	mesbox@hsp mesbox_atoScript, (ginfo_winx - (SCRIPTBOX_buttonW+10))/2, SCRIPTBOX_sizeY, 4, 0
	hMesbox_atoScript = objinfo(stat, 2)
	objsize SCRIPTBOX_buttonW, SCRIPTBOX_buttonH
	pos (ginfo_winx-SCRIPTBOX_buttonW)/2, SCRIPTBOX_posY + (SCRIPTBOX_sizeY-SCRIPTBOX_buttonH)/2
	button@hsp gosub "→スクリプト変更→", *BUTTON_ChangeScript@ObjPosMod
	hButton_changeScript = objinfo(stat, 2)
	objenable stat, 0
	objsize LISTVIEW_buttonW, LISTVIEW_buttonH
	pos (ginfo_winx-LISTVIEW_buttonW)/2, SCRIPTBOX_posY
	button@hsp gosub "↑全選択", *BUTTON_ListAllSelect@ObjPosMod
	hButton_listAllSelect = objinfo(stat, 2)
	
	;// メインウィンドウにオブジェクトを纏めた子ウィンドウを貼り付ける
	bgscr blankWinID, ginfo_sx,CHILDWINDOW_sizeY, 2, 0,CHILDWINDOW_posY
	widMain_child = blankWinID
	hwMain_child = hwnd
	SetParent hwnd,hwMain
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	blankWinID++
	;オブジェクト設定
	objsize 100,
	pos 10,5
	button@hsp gosub "オブジェクト吸着", *CHECKBOX_AlignObj@ObjPosMod
	hButton_alignObj = objinfo(stat, 2)
	sendmsg hButton_alignObj, BM_SETSTYLE, BS_AUTOCHECKBOX
	sendmsg hButton_alignObj, BM_SETCHECK, alignObj
	pos 10, 30
	button@hsp gosub "ドットに合わせる", *CHECKBOX_AlignDot@ObjPosMod
	hButton_alignDot = objinfo(stat, 2)
	sendmsg hButton_alignDot, BM_SETSTYLE, BS_AUTOCHECKBOX
	sendmsg hButton_alignDot, BM_SETCHECK, alignDot
	pos 120, 30
	input_dotInterval = dotInterval
	input@hsp input_dotInterval, 25,
	objsize 110,
	pos 150, 30
	button@hsp gosub "ドット間隔を変更", *BUTTON_DotInterval@ObjPosMod
	color 200,200,200 : line@hsp 280,10,280,ginfo_sy-10
	objsize 85,
	pos 300, 30
	button@hsp gosub "最前面表示", *CHECKBOX_WTopMost@ObjPosMod
	hButton_wTopMost = objinfo(stat, 2)
	sendmsg hButton_wTopMost, BM_SETSTYLE, BS_AUTOCHECKBOX
	sendmsg hButton_wTopMost, BM_SETCHECK, wTopMost
	pos 400, 30 
	button@hsp gosub "ヘルプ", *BUTTON_Help@ObjPosMod
	gsel widMain_child, 1
	
	gsel widMain, 2
	;メインウィンドウoncmd
	oncmd gosub *NOTIFY@ObjPosMod, WM_NOTIFY
	oncmd gosub *RESIZE@ObjPosMod, WM_SIZE
	;マウスフック設定
	newclbk3 ojbposProc, 3, *mHookProc@ObjPosMod
	GetWindowThreadProcessId hwnd, 0
	SetWindowsHookEx WH_MOUSE, ojbposProc, hinstance, stat
	hHook = stat
	
	gsel g_sel
	initedMain=1
	return
*BUTTON_ListAllSelect@ObjPosMod
	SetAllSelect_ListView : ChangedSelectedItem_ListView
	return
*CHECKBOX_AlignObj@ObjPosMod
	alignObj = 1 - alignObj
	if alignObj=1 && alignDot=1 : alignDot = 0 : sendmsg hButton_alignDot, BM_SETCHECK, alignDot
	return
*CHECKBOX_AlignDot@ObjPosMod
	alignDot = 1 - alignDot
	if alignObj=1 && alignDot=1 : alignObj = 0 : sendmsg hButton_alignObj, BM_SETCHECK, alignObj
	return
*BUTTON_DotInterval@ObjPosMod
	g_sel = ginfo_sel
	dotInterval = input_dotInterval
	if dotInterval <= 0 : dotInterval = 1
	foreach widDots
		if widDots(cnt) = 0 : continue
		gsel widDots(cnt)
		DotDraw dotInterval
	loop
	gsel g_sel
	return
*CHECKBOX_WTopMost@ObjPosMod
	g_sel = ginfo_sel
	wTopMost = 1 - wTopMost
	sendmsg hButton_wTopMost, BM_SETCHECK, wTopMost
	gsel widMain, 1 + wTopMost
	gsel g_sel
	return
*BUTTON_Help@ObjPosMod
	g_sel_help = ginfo_sel
	gsel widMain
	dialog {"
		- 1 -
		buttonやboxf等のオブジェクトに対し、Ctrlを押しながらマウスの左ドラッグで位置を変更、右ドラッグでサイズを変更できます。
		- 2 -
		リストからスクリプトを書き換えたいオブジェクトを選択し「スクリプト変更」ボタンを押してください。スクリプトエディタ上の文字が書き換えられます。
		(エディタで開いてない場合は「ファイルを開く」ボタンになります。)
		---
		※  オブジェクトの操作時にあわせてShiftも押すと移動の縦横制限をしたりサイズを縦横同時に合わせることができます。
	"},0,""+_MODULE_NAME_@ObjPosMod+"  -  ヘルプ"
	gsel g_sel_help
	return
//--------------------------------------
// スクリプトエディタ書き換えボタンのラベル
//--------------------------------------
*BUTTON_ChangeScript@ObjPosMod
	GetSelectedItems_ListView selectedItems
	if stat = 0 : return
	dim modIDs, stat
	modIDs_count = 0
	allGreen = 1
	repeat stat
		lv_id = int.GetItem_ListView( selectedItems.cnt, 2 )
		modID = Get_modID_@ObjPosModDataClass( objData, lv_id )
		if hasBeenFixed_@ObjPosModDataClass( objData.modID ) ! 0 : continue ;エディタ書き換え済みのものは弾く
		modIDs( modIDs_count ) = modID : modIDs_count++
		if IsOpenedHspFile_@ObjPosModDataClass( objData.modID ) = 0 {
			;スクリプトエディタで開いてないファイルがある場合はそれを開くだけ開いて、一旦処理を止める
			hspFilePath = Get_fullPath_@ObjPosModScriptClass( hspFile_@ObjPosModDataClass( objData.modID ) )
			exec dir_exe+"\\hsed3.exe \""+hspFilePath+"\""
			allGreen = 0
		}
	loop
	if allGreen {
		EnableWindow hButton_changeScript, 0
		;スクリプトの後ろの方にあるオブジェクトから書き換えていく方が良いため並び変える
		Get_SortedArray_DescendingScriptLine@ObjPosModDataClass objData, modIDs_DESC_scriptLine, modIDs, modIDs_count
		modIDs_count = stat
		;//スクリプトエディタ書き換え実行(モード変更)
		SetMode_OverwriteHsed_@ObjPosModDataClass 1
		repeat modIDs_count
			Update_MaeAtoScript_@ObjPosModDataClass objData,modIDs_DESC_scriptLine(cnt)
		loop
		SetMode_OverwriteHsed_@ObjPosModDataClass 0
	}else {
		string256 = "→スクリプト変更→"
		sendmsg hButton_changeScript, WM_SETTEXT, 0, varptr.string256
	}
	return
	
//--------------------------------------
// ドット表示Winと吸着表示Winの貼り付け
//--------------------------------------
#deffunc local SetDotAndGuidWindow int _sel
	g_sel = ginfo_sel
	
	gsel _sel
	hw = hwnd
	
	;ドット表示bgscrを作成して指定ウィンドウに貼り付け
	bgscr blankWinID, ginfo_sx,ginfo_sy, 2
	widDots(_sel) = blankWinID
	hwDots(_sel) = hwnd
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) | WS_EX_LAYERED | WS_EX_TRANSPARENT	;色とマウスイベントの透過
	SetLayeredWindowAttributes hwnd, 0, 255, LWA_COLORKEY | LWA_ALPHA
	DotDraw dotInterval
	blankWinID++
	
	;吸着表示bgscrを作成して指定ウィンドウに貼り付け
	bgscr blankWinID, ginfo_sx,ginfo_sy, 2
	widGuids(_sel) = blankWinID
	hwGuids(_sel) = hwnd
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) | WS_EX_LAYERED | WS_EX_TRANSPARENT	;色とマウスイベントの透過
	SetLayeredWindowAttributes hwnd, 0, 255*75/100, LWA_COLORKEY | LWA_ALPHA
	blankWinID++

	initedWinID(_sel) = 1
	gsel g_sel
	return
//--------------------------------------
// ドット表示Win吸着表示Winの 表示、非表示
//--------------------------------------
#define ShowDotWindow(%1) SetWindowPos hwDots( %1 ), HWND_BOTTOM, 0,0,0,0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
#define HiddenDotWindow(%1) ShowWindow hwDots( %1 ), SW_HIDE
#define ShowGuidWindow(%1) SetWindowPos hwGuids( %1 ), HWND_TOP, 0,0,0,0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
#define HiddenGuidWindow(%1) ShowWindow hwGuids( %1 ), SW_HIDE
//--------------------------------------
// ドット描画
//--------------------------------------
#deffunc local DotDraw int _interval
	color : boxf@hsp ;背景色塗りつぶし
	color 30,30,30
	if _interval >= 2 {
		repeat ginfo_sy / _interval
			cn = cnt
			repeat ginfo_sx / _interval
				pset cnt * _interval, cn * _interval
			loop
		loop
	}
	return

//--------------------------------------
// 初期化済みか確認 (オブジェクト命令割り込み時にチェックしている)
//--------------------------------------
#deffunc local CheckInited int _sel
	if initedMain = 0 : initObjPos_SetBlankWinID _ObjPosMod_BlankWinID_@
	if length(initedWinID) <= _sel : initedWinID(_sel) = 0
	if initedWinID(_sel) = 0 : SetDotAndGuidWindow _sel ;ドット表示Win吸着表示Winの貼り付け
	return

//--------------------------------------
// 終了処理
//--------------------------------------
#deffunc local exit_objpos onexit
	UnhookWindowsHookEx hHook	;フック解放
	return

//--------------------------------------
// リストビューを作成
//--------------------------------------
#deffunc local createListView int _width, int _height, int _posx, int _posy, int _sizex, int _sizey
	dim lvcolumn, 8
	dim lvitem, 9
	winobj "SysListView32", "", 0x00000200, 0x50000009, _sizex, _sizey
	hList = objinfo(stat, 2)
	SetWindowPos hList, HWND_NOTOPMOST, _posx,_posy,_sizex,_sizey, SWP_NOOWNERZORDER | SWP_NOZORDER
	sendmsg hList, LVM_SETEXTENDEDLISTVIEWSTYLE, , LVS_EX_FULLROWSELECT
	szText = "ファイル名"	: lvcolumn = 0x000F, 0,  10, varptr(szText), 0, 0 : sendmsg hList, LVM_INSERTCOLUMN, 0, varptr(lvcolumn)
	szText = "行数"			: lvcolumn = 0x000F, 0,  50, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 1, varptr(lvcolumn)
	szText = "ID"			: lvcolumn = 0x000F, 0,  50, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 2, varptr(lvcolumn)
	szText = "タイプ"		: lvcolumn = 0x000F, 0,  80, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 3, varptr(lvcolumn)
	szText = "POS"			: lvcolumn = 0x000F, 0, 120, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 4, varptr(lvcolumn)
	szText = "SIZE"			: lvcolumn = 0x000F, 0, 120, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 5, varptr(lvcolumn)
	szText = "備考"			: lvcolumn = 0x000F, 0, 500, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 6, varptr(lvcolumn)
	szText = "カウンタ"		: lvcolumn = 0x000F, 0,  50, varptr(szText), 0, 1 : sendmsg hList, LVM_INSERTCOLUMN, 7, varptr(lvcolumn)
	return

//--------------------------------------
// リストビューにデータをセット (移動中のオブジェクト(複数)をリストの上の方にまとめるため行も指定している)
//--------------------------------------
#deffunc local SetData_ListView int _id, int _gyo
	id = _id //Exp用処置
	;_gyo==-1のときはidに対応する行を探して更新だけ行う
	gyo = _gyo
	sendmsg hlist, LVM_GETITEMCOUNT, 0, 0
	num = stat
	flg = 0 ;行を追加(LVM_INSERTITEM)するかフラグ
	if _gyo ! -1 {
		if num >= gyo {
			if int.GetItem_ListView( gyo, 2 ) ! modID_@ObjPosModDataClass( objData.id ) {
				; もしセットするオブジェクトが指定した行にいなければ前のを探して消す
				repeat num
					if int.GetItem_ListView(cnt,2) = modID_@ObjPosModDataClass( objData.id ) : Sendmsg hlist, LVM_DELETEITEM, cnt, 0 : break
				loop
				flg = 1
			}
		}else : flg = 1
	}else {
		repeat num
			if int.GetItem_ListView(cnt,2) = modID_@ObjPosModDataClass( objData.id ) : gyo = cnt : break
		loop
	}
	if flg = 1 {
		; 行を追加する
		pszText = hspFile_@ObjPosModDataClass( objData.id )      : lvitem = 0x0001, gyo, 0, 0, 0, varptr(pszText) : sendmsg hList, LVM_INSERTITEMA, 0, varptr(lvitem)
		pszText = str.hspLine_@ObjPosModDataClass( objData.id )  : lvitem = 0x0001, gyo, 1, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
		pszText = str.modID_@ObjPosModDataClass( objData.id )    : lvitem = 0x0001, gyo, 2, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
		pszText = objType_@ObjPosModDataClass( objData.id )      : lvitem = 0x0001, gyo, 3, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
		switch objType_@ObjPosModDataClass( objData.id )
			case "mes"     : pszText = opt1_@ObjPosModDataClass( objData.id ) : pszText = strmid( pszText, 0, 64 ) : swbreak
			case "boxf"    : pszText = strf( "COLOR(%d,%d,%d)", colorR_@ObjPosModDataClass( objData.id ), colorG_@ObjPosModDataClass( objData.id ), colorB_@ObjPosModDataClass( objData.id ) ) : swbreak
			case "line"    : swbreak
			case "circle"  : pszText = strf( "COLOR(%d,%d,%d) mode=%d", colorR_@ObjPosModDataClass( objData.id ), colorG_@ObjPosModDataClass( objData.id ), colorB_@ObjPosModDataClass( objData.id ), opt1_@ObjPosModDataClass( objData.id ) ) : swbreak
			case "grect"   : pszText = strf( "COLOR(%d,%d,%d) deg=%0.2f", colorR_@ObjPosModDataClass( objData.id ), colorG_@ObjPosModDataClass( objData.id ), colorB_@ObjPosModDataClass( objData.id ), opt1_@ObjPosModDataClass( objData.id ) ) : swbreak
			case "picload" : pszText = opt1_@ObjPosModDataClass( objData.id ) : pszText = strmid( pszText, 0, 64 ) : swbreak
			case "chkbox"  : ;↓
			case "mesbox"  : ;↓
			case "input"   : ;↓
			case "combox"  : ;↓
			case "listbox" : ;↓
			case "button"  : pszText = opt1_@ObjPosModDataClass( objData.id ) : pszText = strmid( pszText, 0, 64 ) : swbreak
			case "winobj"  : pszText = strf( "Class=%s, Title=%s", opt1_@ObjPosModDataClass( objData.id ), opt2_@ObjPosModDataClass( objData.id ) ) : swbreak
			default        : ; 標準命令になかったら拡張を探る
							 //--------------------------------------
							 // EXP拡張
							 //======================================
							 // *label_ListDetail (ObjPosModのリストの備考に何を書くかを登録するラベル)
							 //--------------------------------------
							 foreach objExp@ObjPosModDataClass
								if objType_@ObjPosModDataClass( objData.id ) = objType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) : label_ListDetail_@ObjPosModExpClass objExp@ObjPosModDataClass.cnt : mref refst,65:refst="" : gosub refLabel@ObjPosModExpClass : pszText = refstr : break
							 loop
		swend                                                    : lvitem = 0x0001, gyo, 6, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
	}
	; 行の内容を更新する
	pszText = strf( "POS( %d, %d )", pos_x1_@ObjPosModDataClass( objData.id ), pos_y1_@ObjPosModDataClass( objData.id ) )
	                                                             : lvitem = 0x0001, gyo, 4, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
	pszText = strf( "SIZE( %d, %d )", size_w1_@ObjPosModDataClass( objData.id ), size_h1_@ObjPosModDataClass( objData.id ) )
							 if objType_@ObjPosModDataClass( objData.id ) = "mes" {
								if opt3_@ObjPosModDataClass( objData.id ) ! "sysfont" {
							 		pszText = strf( "FONT( %s )", opt5_@ObjPosModDataClass( objData.id ) )
							 	}else {
								 	pszText = strf( "SYSFONT( %s )", opt6_@ObjPosModDataClass( objData.id ) )
								}
							 }
	                                                             : lvitem = 0x0001, gyo, 5, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
	pszText = str.changedCount_@ObjPosModDataClass( objData.id ) : lvitem = 0x0001, gyo, 7, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
	;lineだけオブジェクトの変更で備考が変化する
	if objType_@ObjPosModDataClass( objData.id ) = "line" {
		switch opt2_@ObjPosModDataClass( objData.id )
			case 0 : pszText = "左上への直線 " : swbreak
			case 1 : pszText = "右下への直線 " : swbreak
			case 2 : pszText = "左下への直線 " : swbreak
			default: pszText = "右上への直線 " : swbreak
		swend
		pszText += strf( "COLOR(%d,%d,%d)", colorR_@ObjPosModDataClass( objData.id ), colorG_@ObjPosModDataClass( objData.id ), colorB_@ObjPosModDataClass( objData.id ) )
		                                                         : lvitem = 0x0001, gyo, 6, 0, 0, varptr(pszText) : sendmsg hList, LVM_SETITEMA,    0, varptr(lvitem)
	}
	return
//--------------------------------------
// リストビューの文字列を取得
//--------------------------------------
#defcfunc local GetItem_ListView int _gyo, int _retu
	if _gyo<0 || _retu<0 :return ""
	lvitem  = $00000001, _gyo, _retu, 0, 0, varptr(string256), 256
	sendmsg hlist, LVM_GETITEM, 0, varptr(lvitem)
	return string256
//--------------------------------------
// リストビューで選択状態のアイテムを取得
//--------------------------------------
#deffunc local GetSelectedItems_ListView array items
	dim items, 1
	iStart = -1
	num = 0
	repeat
		sendmsg hList, LVM_GETNEXTITEM, iStart, LVNI_ALL | LVNI_SELECTED
		if stat = -1 : break
		items(cnt) = stat
		num++
		iStart = stat
	loop
	return num
//--------------------------------------
// リストビューの選択状態をすべて解除
//--------------------------------------
#deffunc local ClearAllSelected_ListView
	iStart = -1
	repeat
		sendmsg hList, LVM_GETNEXTITEM, iStart, LVNI_ALL | LVNI_SELECTED
		if stat = -1 : break
		iStart = stat
		lvitem = 0x0008, iStart, 0,  0, -1
		sendmsg hList, LVM_SETITEMA, 0, varptr(lvitem)
	loop
	return
//--------------------------------------
// リストビューのアイテムをすべて選択
//--------------------------------------
#deffunc local SetAllSelect_ListView
	iStart = -1
	repeat
		sendmsg hList, LVM_GETNEXTITEM, iStart, LVNI_ALL
		if stat = -1 : break
		iStart = stat
		lvitem = 0x0008, iStart, 0,  2, -1
		sendmsg hList, LVM_SETITEMA, 0, varptr(lvitem)
	loop
	return
//--------------------------------------
// リストビューのID(カラム2)が配列dataids内の値と合致するものをすべて選択状態にする
//--------------------------------------
#deffunc local SetSelectDataIDs_ListView array _objData, array dataids
	sendmsg hlist, LVM_GETITEMCOUNT, 0, 0
	repeat stat
		id_item = int.GetItem_ListView(cnt,2)
		cn = cnt
		foreach dataids : if dataids(cnt) < 0 : continue
			if id_item = modID_@ObjPosModDataClass( _objData.dataids(cnt) ) : lvitem = 0x0008, cn, 0,  LVNI_SELECTED, -1 : sendmsg hList, LVM_SETITEMA, 0, varptr(lvitem)
		loop
	loop
	return

//--------------------------------------
// BlackList WhiteList でNGなWinIDかどうかを返す
//--------------------------------------
#defcfunc local NG_BlackOrWhite int wID
	ng = 0
	if _ObjPosMod_BlackListID_@ ! -1 {
		; BlackListがある場合、一致したIDのものだけがNGになる。
		foreach _ObjPosMod_BlackListID_@
			if _ObjPosMod_BlackListID_@(cnt) = wID : ng = 1
		loop
	}
	if _ObjPosMod_WhiteListID_@ ! -1 {
		; WhiteListがある場合、一致するもの以外のIDがNGになる。
		; ただし両方あった場合、基本Black側の考えとなるがWhiteにも重複したIDがある場合はOKとなる(NGにならない)。
		if _ObjPosMod_BlackListID_@ = -1 : ng = 1
		foreach _ObjPosMod_WhiteListID_@
			if _ObjPosMod_WhiteListID_@(cnt) = wID : ng = 0
		loop
	}
	return ng

//------------------------------------------------------------------------------
// End of メインウィンドウの作成や操作関数
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// HSPの命令をObjPosMod用に置換
//------------------------------------------------------------------------------
//--------------------------------------
// mes
//--------------------------------------
#undef mes
#undef print
#define global print mes
#define global mes(%1,%2=0) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : dp1@ObjPosMod=""+%1 : _mes@ObjPosMod dp1@ObjPosMod,%2
#deffunc _mes@ObjPosMod str sp1, int p2
	st=stat
	mref bmscr, 67
	if TanrakuOR( sp1="" , bmscr.17=WIN_TYPE_BUFFER , NG_BlackOrWhite( ginfo_sel ) , isCreated@ObjPosModDataClass( objData, ScFile, ScLine, "mes" ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : mes@hsp sp1, p2 : return st
	CheckInited ginfo_sel

	;記録する
	hw = hwnd
	sel=ginfo_sel
	col=ginfo_r, ginfo_g, ginfo_b
	posi = ginfo_cx, ginfo_cy
	;フォント系の取得
	if stockObjects = 0 : stockObjects.0 = GetStockObject(17), GetStockObject(13), GetStockObject(12), GetStockObject(11), GetStockObject(10) : stockObjectIDs = 17, 13, 12, 11, 10
	;まずsysfont設定か確認する
	c = -1 : repeat length.stockObjects :if( bmscr.38 = stockObjects.cnt ){ c = cnt : break } : loop
	if c ! -1 {
		//sysfont
		lfFaceName = "sysfont"
		f_style = stockObjectIDs( c )
		f_size = 0
		objcolRef = 0
		f_effsize = 0
	}else {
		//font
		#if __hspver__ < $3603
			objcolRef = 0
			f_effsize = 0
		#else
			objcolRef = bmscr.86
			f_effsize = bmscr.87
		#endif
		#if __hspver__ < $3607
			f_size = -bmscr.49
			f_style = (bmscr.53>=700)|peek(bmscr.54, 0)<<1|peek(bmscr.54, 1)<<2|peek(bmscr.54, 2)<<3|(peek(bmscr.55, 2)>0)<<4
			sdim lfFaceName
			dupptr lfFaceName, varptr(bmscr.56), 32, 2
		#else
			dupptr logfont, bmscr.49, 60, 4
			f_size = -logfont.0
			f_style = (logfont.4>=700)|peek(logfont.5, 0)<<1|peek(logfont.5, 1)<<2|peek(logfont.5, 2)<<3|(peek(logfont.6, 2)>0)<<4
			sdim lfFaceName
			getstr lfFaceName, logfont, 28
		#endif
	}
	;objsizeの p3:Y方向の最低確保行サイズ を取得
	objsize_py = bmscr.31
	
	;サイズを可変にするためあらかじめウィンドウサイズぶん確保しておく
	set = ginfo_sx, ginfo_sy
	;子ウィンドウとして貼り付け
	bgscr blankWinID, set(0), set(1), 2
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) |WS_EX_LAYERED
	SetLayeredWindowAttributes hwnd, bgColorR|bgColorG<<8|bgColorb<<16, 255, LWA_COLORKEY | LWA_ALPHA

	;mesサイズ取得と調整
	if lfFaceName = "sysfont" {
		sysfont f_style
	}else {
		#if __hspver__ < $3603
			font lfFaceName, f_size, f_style
		#else
			objcolor objcolRef & $FF, (objcolRef>>8) & $FF, (objcolRef>>16) & $FF
			font lfFaceName, f_size, f_style, f_effsize
		#endif
	}
	objsize ,,objsize_py
	pos 0,0
	mes@hsp sp1, p2|1   : w = ginfo_cx
	mes@hsp sp1, p2|1^1 : h = ginfo_cy
	pos 0,0
	size = w, h
	SetWindowPos hwnd, HWND_NOTOPMOST, posi(0),posi(1), size(0),size(1), SWP_NOOWNERZORDER | SWP_NOZORDER

	;子ウィンドウに内容を描画
	color bgColorR, bgColorG, bgColorB
	boxf@hsp
	color col(0), col(1), col(2)
	mes@hsp sp1, p2
	g_mesxy = ginfo_mesx, ginfo_mesy
	set = ginfo_cx, ginfo_cy
	pos 0,0
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, sel, hw, blankWinID, hwnd, "mes", posi(0),posi(1), size(0),size(1), posi(0)+set(0),posi(1)+set(1), objsize_py, col(0),col(1),col(2), ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, sp1
	Set_opt2_@ObjPosModDataClass objData.modvID, p2
	Set_opt3_@ObjPosModDataClass objData.modvID, lfFaceName
	Set_opt4_@ObjPosModDataClass objData.modvID, f_size ;変更前
	Set_opt5_@ObjPosModDataClass objData.modvID, f_size ;変更後
	Set_opt6_@ObjPosModDataClass objData.modvID, f_style
	Set_opt7_@ObjPosModDataClass objData.modvID, f_effsize
	
	gsel blankWinID, 1
	blankWinID++
	gsel sel
	
	bmscr.68 = g_mesxy(0), g_mesxy(1) ;ginfo_mesx,ginfo_mesyを調整する
	pos ginfo_cx + set(0), ginfo_cy + set(1) ;元のウィンドウのカレントポジションを調整する
	return st
	
// 指定枠内で最大のフォントサイズを取得(ついでに描画もしてしまう)
//======================================
// outArray : f_size(問い合わせサイズ内で最大のフォントサイズ), w(そのときの幅), h(そのときの高さ) の配列を返す
// v        : 問合せしたいオブジェクト(mes)が格納されているobjDataのモジュール変数
// pw       : 指定した幅
// ph       : 指定した高さ
#deffunc GetMaxFontSizeWH array outArray, var v, int pw, int ph
	dim outArray, 3
	if opt3_@ObjPosModDataClass( v ) = "sysfont" : return
	sel = ginfo_sel
	gsel objID_@ObjPosModDataClass( v )
	redraw 0
	
	mes_text   = opt1_@ObjPosModDataClass( v )
	mes_sw     = opt2_@ObjPosModDataClass( v )
	lfFaceName = opt3_@ObjPosModDataClass( v )
	f_size     = opt5_@ObjPosModDataClass( v )
	f_style    = opt6_@ObjPosModDataClass( v )
	f_effsize  = opt7_@ObjPosModDataClass( v )
	set(0)     = size_w2_@ObjPosModDataClass( v )
	set(1)     = size_h2_@ObjPosModDataClass( v )
	c = -1
	;上げ
	repeat
		if (f_size+cnt) > 1638 : break
		#if __hspver__ < $3603
			font lfFaceName, f_size+cnt, f_style
		#else
			font lfFaceName, f_size+cnt, f_style, f_effsize
		#endif
		mes@hsp mes_text, mes_sw|1   : w = ginfo_cx
		mes@hsp mes_text, mes_sw|1^1 : h = ginfo_cy
		pos 0,0
		if w > pw || h > ph : break ;問い合わせサイズをはみ出た。その１つ前が確定(ただし今cnt==0だったら下げ確認)
		set = w,h
		c = cnt
	loop
	if c = -1 {
		//大きくする方向では決まらなかった。小さくする方向で調べる。
		;下げ
		repeat ,1
			if (f_size-cnt) <= 0 : break
			#if __hspver__ < $3603
				font lfFaceName, f_size-cnt, f_style
			#else
				font lfFaceName, f_size-cnt, f_style, f_effsize
			#endif
			mes@hsp mes_text, mes_sw|1   : w = ginfo_cx
			mes@hsp mes_text, mes_sw|1^1 : h = ginfo_cy
			pos 0,0
			if w <= pw || h <= ph { ;問い合わせサイズに納まった瞬間が確定サイズ。
				set = w,h
				c = cnt
				break
			}
		loop
		if c ! -1 {
			f_size -= c ;下げ確定
		}
	}else {
		f_size += c ;上げ確定
	}
	outArray = f_size, set(0), set(1)

	;描画しなおして綺麗に
	color bgColorR, bgColorG, bgColorB
	boxf@hsp
	#if __hspver__ < $3603
		font lfFaceName, f_size, f_style
	#else
		font lfFaceName, f_size, f_style, f_effsize
	#endif
	color colorR_@ObjPosModDataClass( v ), colorG_@ObjPosModDataClass( v ), colorB_@ObjPosModDataClass( v )
	mes@hsp mes_text, mes_sw
	pos 0,0
	
	redraw 1
	gsel sel
	return

//--------------------------------------
// boxf
//--------------------------------------
#undef boxf
#define global boxf(%1=0,%2=0,%3=ginfo_sx,%4=ginfo_sy) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _boxf@ObjPosMod %1,%2,%3,%4
#deffunc _boxf@ObjPosMod int p1, int p2, int p3, int p4
	st=stat
	mref bmscr, 67
	if TanrakuOR( p1=0&p2=0&p3=ginfo_sx&p4=ginfo_sy , bmscr.17=WIN_TYPE_BUFFER , NG_BlackOrWhite( ginfo_sel ) , isCreated@ObjPosModDataClass( objData, ScFile, ScLine, "boxf" ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : boxf@hsp p1,p2,p3,p4 : return st ;boxf全省略(全体塗り)の場合オブジェクトとして管理しない
	CheckInited ginfo_sel
	
	hw = hwnd
	sel = ginfo_sel
	col = ginfo_r, ginfo_g, ginfo_b
	size = p3-p1+1, p4-p2+1 ;初期値とスクリプト書き換え時に細工をしている
	posi = p1, p2
	cxy = ginfo_cx, ginfo_cy
	objsize_py = bmscr.31
	;サイズを可変にするためあらかじめウィンドウサイズぶん確保しておく
	set = size(0), size(1)
	if set(0) < ginfo_sx : set(0) = ginfo_sx
	if set(1) < ginfo_sy : set(1) = ginfo_sy
	;子ウィンドウとして貼り付け
	bgscr blankWinID, set(0), set(1), 2, posi(0), posi(1)
	width size(0), size(1)
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) |WS_EX_LAYERED
	SetLayeredWindowAttributes hwnd, bgColorR|bgColorG<<8|bgColorb<<16, 255, LWA_COLORKEY | LWA_ALPHA
	
	;子ウィンドウに内容を描画
	color col(0), col(1), col(2)
	boxf@hsp
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, sel, hw, blankWinID, hwnd, "boxf", posi(0),posi(1), size(0),size(1), cxy(0),cxy(1), objsize_py, col(0),col(1),col(2), ScFile, ScLine

	gsel blankWinID, 1
	blankWinID++
	gsel sel
	return st

//--------------------------------------
// line
//--------------------------------------
#undef line
#define global line(%1=0,%2=0,%3=ginfo_cx,%4=ginfo_cy) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _line@ObjPosMod %1,%2,%3,%4
#deffunc _line@ObjPosMod int xe, int ye, int xs, int ys
	st=stat
	mref bmscr, 67
	if TanrakuOR( bmscr.17=WIN_TYPE_BUFFER , NG_BlackOrWhite( ginfo_sel ) , isCreated@ObjPosModDataClass( objData, ScFile, ScLine, "line" ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : line@hsp xe,ye,xs,ys : return st
	CheckInited ginfo_sel
	
	hw = hwnd
	sel = ginfo_sel
	col = ginfo_r, ginfo_g, ginfo_b
	size = abs(xs-xe), abs(ys-ye)
	// オブジェクトの位置移動、もしくはサイズ変更(右下座標のみ)しか対応していない。
	// よって一度のサイズ変更で縦横無尽に一回転させたりとかはできない。無理くりタイプ分けして制限のあるサイズ変更操作となる。
	        if xs >= xe & ys >= ye { : type = 0  : posi = xe, ye ;左上へ
	}else : if xs <  xe & ys <  ye { : type = 1  : posi = xs, ys ;右下へ
	}else : if xs >= xe & ys <  ye { : type = 2  : posi = xe, ys ;左下へ
	}else/* if xs <  xe & ys >= ye */: type = 3  : posi = xs, ye ;右上へ
	/*}*/
	
	objsize_py = bmscr.31
	;サイズを可変にするためあらかじめウィンドウサイズぶん確保しておく
	set = size(0), size(1), size(0)+1, size(1)+1 ;line用の細工
	if set(0) < ginfo_sx : set(0) = ginfo_sx
	if set(1) < ginfo_sy : set(1) = ginfo_sy
	;子ウィンドウとして貼り付け
	bgscr blankWinID, set(0), set(1), 2, posi(0), posi(1)
	width set(2), set(3)
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) |WS_EX_LAYERED
	SetLayeredWindowAttributes hwnd, bgColorR|bgColorG<<8|bgColorb<<16, 255, LWA_COLORKEY | LWA_ALPHA
	
	;子ウィンドウに内容を描画
	color bgColorR, bgColorG, bgColorB
	boxf@hsp
	color col(0), col(1), col(2)
	switch type
		case 0 : line@hsp     0,     0, xs-xe, ys-ye : swbreak
		case 1 : line@hsp xe-xs, ye-ys,     0,     0 : swbreak
		case 2 : line@hsp     0, ye-ys, xs-xe,     0 : swbreak
		default: line@hsp xe-xs,     0,     0, ys-ye : swbreak
	swend
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, sel, hw, blankWinID, hwnd, "line", posi(0),posi(1), size(0),size(1), xe,ye, objsize_py, col(0),col(1),col(2), ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, type ;変更前
	Set_opt2_@ObjPosModDataClass objData.modvID, type ;変更中
	Set_opt3_@ObjPosModDataClass objData.modvID, type ;変更後
	
	gsel blankWinID, 1
	blankWinID++
	gsel sel
	pos xe, ye	;line命令は p1,p2 がカレントポジションになる
	return st

//--------------------------------------
// circle
//--------------------------------------
#undef circle
#define global circle(%1=0,%2=0,%3=ginfo_sx,%4=ginfo_sy,%5=1) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _circle@ObjPosMod %1,%2,%3,%4,%5
#deffunc _circle@ObjPosMod int p1, int p2, int p3, int p4, int p5
	st=stat
	mref bmscr, 67
	if TanrakuOR( bmscr.17=WIN_TYPE_BUFFER , NG_BlackOrWhite( ginfo_sel ) , isCreated@ObjPosModDataClass( objData, ScFile, ScLine, "circle" ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : circle@hsp p1,p2,p3,p4,p5 : return st
	CheckInited ginfo_sel
	
	hw = hwnd
	sel = ginfo_sel
	col = ginfo_r, ginfo_g, ginfo_b
	size = p3-p1, p4-p2
	posi = p1, p2
	cxy = ginfo_cx, ginfo_cy
	objsize_py = bmscr.31
	;サイズを可変にするためあらかじめウィンドウサイズぶん確保しておく
	set = size(0), size(1)
	if set(0) < ginfo_sx : set(0) = ginfo_sx
	if set(1) < ginfo_sy : set(1) = ginfo_sy
	;子ウィンドウとして貼り付け
	bgscr blankWinID, set(0), set(1), 2, posi(0), posi(1)
	width size(0), size(1)
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) |WS_EX_LAYERED
	SetLayeredWindowAttributes hwnd, bgColorR|bgColorG<<8|bgColorb<<16, 255, LWA_COLORKEY | LWA_ALPHA
	
	;子ウィンドウに内容を描画
	color bgColorR, bgColorG, bgColorB
	boxf@hsp
	color col(0), col(1), col(2)
	circle@hsp 0, 0, p3-p1, p4-p2, p5

	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, sel, hw, blankWinID, hwnd, "circle", posi(0),posi(1), size(0),size(1), cxy(0),cxy(1), objsize_py, col(0),col(1),col(2), ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p5

	gsel blankWinID, 1
	blankWinID++
	gsel sel
	return st

//--------------------------------------
// grect
//--------------------------------------
#undef grect
#define global grect(%1=0,%2=0,%3=0.0,%4=-1,%5=-1) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _grect@ObjPosMod %1,%2,%3,%4,%5
#deffunc _grect@ObjPosMod int p1, int p2, double p3, int p4, int p5
	st=stat
	w = p4 : h = p5
	mref bmscr, 67
	if w = -1 : w = bmscr.33 ;BMSCR_gx //gcopy size
	if h = -1 : h = bmscr.34 ;BMSCR_gy
	if TanrakuOR( p3=-1.0 , bmscr.17=WIN_TYPE_BUFFER , NG_BlackOrWhite( ginfo_sel ) , isCreated@ObjPosModDataClass( objData, ScFile, ScLine, "grect" ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : grect@hsp p1,p2,p3,w,h : return st
	CheckInited ginfo_sel
	
	hw = hwnd
	sel = ginfo_sel
	col = ginfo_r, ginfo_g, ginfo_b
	size = int(absf(cos(p3)*w)+absf(sin(p3)*h)), int(absf(sin(p3)*w)+absf(cos(p3)*h))
	posi = p1-size(0)/2, p2-size(1)/2
	cxy = ginfo_cx, ginfo_cy
	objsize_py = bmscr.31
	;サイズを可変にするためあらかじめウィンドウサイズぶん確保しておく
	set = size(0), size(1)
	if set(0) < ginfo_sx : set(0) = ginfo_sx
	if set(1) < ginfo_sy : set(1) = ginfo_sy
	;子ウィンドウとして貼り付け
	bgscr blankWinID, set(0), set(1), 2, posi(0), posi(1)
	width size(0), size(1)
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) |WS_EX_LAYERED
	SetLayeredWindowAttributes hwnd, bgColorR|bgColorG<<8|bgColorb<<16, 255, LWA_COLORKEY | LWA_ALPHA
	
	;子ウィンドウに内容を描画
	color bgColorR, bgColorG, bgColorB
	boxf@hsp
	color col(0), col(1), col(2)
	grect@hsp size(0)/2, size(1)/2, p3, w, h

	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, sel, hw, blankWinID, hwnd, "grect", posi(0),posi(1), size(0),size(1), cxy(0),cxy(1), objsize_py, col(0),col(1),col(2), ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p3
	
	gsel blankWinID, 1
	blankWinID++
	gsel sel
	return st

//--------------------------------------
// picload
//--------------------------------------
#undef picload
#define global picload(%1,%2=0) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _picload@ObjPosMod %1,%2
#deffunc _picload@ObjPosMod str p1, int p2
	st=stat
	mref bmscr, 67
	if TanrakuOR( p2!1 , bmscr.17=WIN_TYPE_BUFFER , NG_BlackOrWhite( ginfo_sel ) , isCreated@ObjPosModDataClass( objData, ScFile, ScLine, "picload" ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : picload@hsp p1,p2 : return st
	CheckInited ginfo_sel
	
	hw = hwnd
	sel = ginfo_sel
	col = ginfo_r, ginfo_g, ginfo_b
	posi = ginfo_cx, ginfo_cy
	objsize_py = bmscr.31
	;画像のサイズを取得するため一度bufferに読み込む
	buffer blankWinID, 1, 1
	picload@hsp p1, 0
	size = ginfo_sx, ginfo_sy
	buffer blankWinID, 1, 1
	blankWinID++
	;子ウィンドウとして貼り付け
	bgscr blankWinID, size(0), size(1), 2
	color bgColorR, bgColorG, bgColorB : boxf@hsp ;透過pngを考慮して背景色で塗りつぶして、その上にpicload
	picload@hsp p1, 1
	SetParent hwnd,hw
	SetWindowLong hwnd, GWL_STYLE, GetWindowLong(hwnd,GWL_STYLE) | WS_POPUP^WS_POPUP | WS_CHILD
	SetWindowLong hwnd, GWL_EXSTYLE, GetWindowLong(hwnd,GWL_EXSTYLE) |WS_EX_LAYERED
	SetLayeredWindowAttributes hwnd, (bgColorR-PL_ALPHABUG_FIX)|(bgColorG-PL_ALPHABUG_FIX)<<8|(bgColorb-PL_ALPHABUG_FIX)<<16, 255, LWA_COLORKEY | LWA_ALPHA ;picloadバグ対応
	SetWindowPos hwnd, HWND_NOTOPMOST, posi(0),posi(1),,, SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOSIZE
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, sel, hw, blankWinID, hwnd, "picload", posi(0),posi(1), size(0),size(1), posi(0),posi(1), objsize_py, col(0),col(1),col(2), ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p1
	
	gsel blankWinID, 1
	blankWinID++
	gsel sel
	return st

//--------------------------------------
// chkbox
//--------------------------------------
#undef chkbox
#define global chkbox(%1,%2) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _chkbox@ObjPosMod %1,%2
#deffunc _chkbox@ObjPosMod str p1, var p2
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : chkbox@hsp p1,p2 : return
	CheckInited ginfo_sel
	mref bmscr,67
	posi = ginfo_cx, ginfo_cy
	size = bmscr.29, bmscr.30 ;BMSCR_ox, BMSCR_oy //object size
	objsize_py = bmscr.31
	chkbox@hsp p1,p2
	st=stat
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, ginfo_sel, hwnd, st, objinfo_hwnd(st), "chkbox", posi(0),posi(1), size(0),size(1), ginfo_cx,ginfo_cy, objsize_py, ginfo_r,ginfo_g,ginfo_b, ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p1
	return st

//--------------------------------------
// mesbox
//--------------------------------------
#undef mesbox
#define global mesbox(%1,%2=0,%3=0,%4=1,%5=-1) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _mesbox@ObjPosMod %1,%2,%3,%4,%5
#deffunc _mesbox@ObjPosMod var p1, int p2, int p3, int p4, int p5
	x = p2 : y = p3
	mref bmscr,67
	if x = 0 : x = bmscr.29 ;BMSCR_ox //object size
	if y = 0 : y = bmscr.30 ;BMSCR_oy
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : mesbox@hsp p1,x,y,p4,p5 : return
	CheckInited ginfo_sel
	posi = ginfo_cx, ginfo_cy
	size = x, y
	objsize_py = bmscr.31
	mesbox@hsp p1,x,y,p4,p5
	st=stat
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, ginfo_sel, hwnd, st, objinfo_hwnd(st), "mesbox", posi(0),posi(1), size(0),size(1), ginfo_cx,ginfo_cy, objsize_py, ginfo_r,ginfo_g,ginfo_b, ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p1
	return st
	
//--------------------------------------
// input
//--------------------------------------
#undef input
#define global input(%1,%2=0,%3=0,%4=-1) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _input@ObjPosMod %1,%2,%3,%4
#deffunc _input@ObjPosMod var p1, int p2, int p3, int p4
	x = p2 : y = p3
	mref bmscr,67
	if x = 0 : x = bmscr.29 ;BMSCR_ox //object size
	if y = 0 : y = bmscr.30 ;BMSCR_oy
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : input@hsp p1,x,y,p4 : return
	CheckInited ginfo_sel
	posi = ginfo_cx, ginfo_cy
	size = x, y
	objsize_py = bmscr.31
	input@hsp p1,x,y,p4
	st=stat
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, ginfo_sel, hwnd, st, objinfo_hwnd(st), "input", posi(0),posi(1), size(0),size(1), ginfo_cx,ginfo_cy, objsize_py, ginfo_r,ginfo_g,ginfo_b, ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, ""+p1
	return st

//--------------------------------------
// combox
//--------------------------------------
#undef combox
#define global combox(%1,%2=100,%3="") ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _combox@ObjPosMod %1,%2,%3
#deffunc _combox@ObjPosMod var p1, int p2, str p3
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : combox@hsp p1,p2,p3 : return
	CheckInited ginfo_sel
	mref bmscr,67
	posi = ginfo_cx, ginfo_cy
	size = bmscr.29, bmscr.30 ;BMSCR_ox, BMSCR_oy //object size
	objsize_py = bmscr.31
	combox@hsp p1,p2,p3
	st=stat
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, ginfo_sel, hwnd, st, objinfo_hwnd(st), "combox", posi(0),posi(1), size(0),size(1), ginfo_cx,ginfo_cy, objsize_py, ginfo_r,ginfo_g,ginfo_b, ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p3
	return st

//--------------------------------------
// listbox
//--------------------------------------
#undef listbox
#define global listbox(%1,%2=100,%3="") ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _listbox@ObjPosMod %1,%2,%3
#deffunc _listbox@ObjPosMod var p1, int p2, str p3
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : listbox@hsp p1,p2,p3 : return
	CheckInited ginfo_sel
	mref bmscr,67
	posi = ginfo_cx, ginfo_cy
	size = bmscr.29, bmscr.30 + p2 ;BMSCR_ox, BMSCR_oy //object size
	objsize_py = bmscr.31
	listbox@hsp p1,p2,p3
	st=stat
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, ginfo_sel, hwnd, st, objinfo_hwnd(st), "listbox", posi(0),posi(1), size(0),size(1), ginfo_cx,ginfo_cy, objsize_py, ginfo_r,ginfo_g,ginfo_b, ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p3
	Set_opt2_@ObjPosModDataClass objData.modvID, p2 ;スクリプト書き換え時に必要
	return st

//--------------------------------------
// winobj
//--------------------------------------
#undef winobj
#define global winobj(%1="",%2="",%3=0,%4=0,%5=0,%6=0,%7=0,%8=0) ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__  : _winobj@ObjPosMod %1,%2,%3,%4,%5,%6,%7,%8
#deffunc _winobj@ObjPosMod str p1, str p2, int p3, int p4, int p5, int p6, int p7, int p8
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : winobj@hsp p1,p2,p3,p4,p5,p6,p7,p8 : return
	CheckInited ginfo_sel
	x = p5 : y = p6
	mref bmscr,67
	if x = 0 : x = bmscr.29 ;BMSCR_ox //object size
	if y = 0 : y = bmscr.30 ;BMSCR_oy
	posi = ginfo_cx, ginfo_cy
	size = x, y
	objsize_py = bmscr.31
	winobj@hsp p1,p2,p3,p4,p5,p6,p7,p8
	st=stat
	
	;詳細をモジュール型変数に記憶
	newmod objData, ObjPosModDataClass, ginfo_sel, hwnd, st, objinfo_hwnd(st), "winobj", posi(0),posi(1), size(0),size(1), ginfo_cx,ginfo_cy, objsize_py, ginfo_r,ginfo_g,ginfo_b, ScFile, ScLine
	modvID = stat
	Set_opt1_@ObjPosModDataClass objData.modvID, p1
	Set_opt2_@ObjPosModDataClass objData.modvID, p2
	return st

//--------------------------------------
// button
//--------------------------------------
#undef button
#define global button ScFile@ObjPosMod=__file__ : ScLine@ObjPosMod=__line__ : _buttonDataRec@ObjPosMod : button@hsp
#deffunc _buttonDataRec@ObjPosMod
	st=stat
	if TanrakuOR( NG_BlackOrWhite( ginfo_sel ) , IsInsideExpObj@ObjPosModExpClass(ScFile,ScLine) ) : return st
	CheckInited ginfo_sel 
	; この時点ではまだボタンが作られていないからオブジェクトのハンドル等は取得できない。
	; buttonの goto, gosub が#defineでは表現できないので、button命令が出た時の各種情報を保存しておき、後からobjDataに登録をする。
	btnData_line( btnData_count ) = ScLine
	btnData_file( btnData_count ) = ScFile
	btnData_gsel( btnData_count ) = ginfo_sel
	mref bmscr, 67
	btnData_objID( btnData_count ) = bmscr.72 ;BMSCR_objmax //Max number of obj
	btnData_posiX( btnData_count ) = ginfo_cx
	btnData_posiY( btnData_count ) = ginfo_cy
	btnData_sizeX( btnData_count ) = bmscr.29 ;BMSCR_ox //object size
	btnData_sizeY( btnData_count ) = bmscr.30 ;BMSCR_oy
	btnData_keepY( btnData_count ) = bmscr.31 ;BMSCR_py
	btnData_colR( btnData_count ) = ginfo_r
	btnData_colG( btnData_count ) = ginfo_g
	btnData_colB( btnData_count ) = ginfo_b
	btnData_count++
	return st
//記録を遅延させていたボタン群をobjDataに登録
#deffunc local SetObjData_BUTTONs
	if btnData_count <= btnData_SYORIZUMI_count : return ;後からbtnDataが増えることも？
	sel = ginfo_sel
	repeat btnData_count
		if btnData_gsel(cnt) < 0 : continue ;処理済み
		gsel btnData_gsel(cnt)
		hw = objinfo_hwnd( btnData_objID( cnt ) )
		sendmsg hw, WM_GETTEXT, 256, varptr.string256 ;オブジェクトからテキストを取得

		cxy = btnData_posiX(cnt), btnData_posiY(cnt) + btnData_sizeY(cnt)
		if btnData_sizeY(cnt) < btnData_keepY(cnt) : cxy(1) = btnData_posiY(cnt) + btnData_keepY(cnt)
		
		;詳細をモジュール型変数に記憶
		newmod objData, ObjPosModDataClass, btnData_gsel(cnt), hwnd, btnData_objID(cnt), hw, "button", btnData_posiX(cnt),btnData_posiY(cnt), btnData_sizeX(cnt),btnData_sizeY(cnt), cxy(0),cxy(1), btnData_keepY(cnt), btnData_colR(cnt),btnData_colG(cnt),btnData_colB(cnt), btnData_file(cnt), btnData_line(cnt)
		modvID = stat
		Set_opt1_@ObjPosModDataClass objData.modvID, string256

		;処理済み印
		btnData_gsel(cnt) = -1
		btnData_SYORIZUMI_count++
	loop
	gsel sel
	return
//------------------------------------------------------------------------------
// End of HSPの命令をオブジェクト配置モジュール用に置換
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// メッセージ監視
//------------------------------------------------------------------------------
//--------------------------------------
// マウスフック :オブジェクトの移動/サイズ変更操作
//--------------------------------------
*mHookProc@ObjPosMod
	dupptr clbkarg, lparam, wparam*4, 4
	nCode = clbkarg(0)
	wp = clbkarg(1)
	lp = clbkarg(2)
	if nCode < 0 : CallNextHookEx hHook, nCode, wp, lp : return stat

	//mode
	#enum MODE_NONE 0
	#enum MODE_NONE_CHANGED
	#enum MODE_MOVE
	#enum MODE_MOVING
	#enum MODE_SIZE
	#enum MODE_SIZING
	
	getkey ctrl, 17
	if ctrl = 0 {
		if CountData( selectDataIDs ) > 0 {
			//mode解除
			ModeBreak : if 0 { ;なんかこのせせこましい処理を複数箇所で書く必要が出たので、ここの周りで命令化させてもらう
			#deffunc local ModeBreak
				mode = MODE_NONE
				wpEVENT = 0
				foreach selectDataIDs : if selectDataIDs(cnt) < 0 : continue
					//pos,sizeを確定する
					Set_pos_xy2_@ObjPosModDataClass objData.selectDataIDs(cnt), pos_x1_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), pos_y1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					Set_size_wh2_@ObjPosModDataClass objData.selectDataIDs(cnt), size_w1_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), size_h1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					; lineの場合タイプも確定
					if objType_@ObjPosModDataClass( objData.selectDataIDs(cnt) ) = "line" : Set_opt3_@ObjPosModDataClass objData.selectDataIDs(cnt), opt2_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					//スクリプト(変更前[maeScript]、変更後[atoScript])を更新
					Update_MaeAtoScript_@ObjPosModDataClass objData,selectDataIDs(cnt)
					//ドットウィンドウと吸着ウィンドウの非表示
					HiddenDotWindow winID_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					HiddenGuidWindow winID_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
				loop
				SetLayered_SelectingObject SW_HIDE ;選択オブジェクトの見た目を戻す
				//リストビュー(選択クリア → アイテム選択 → 選択アイテム変化時の処理)
				ClearAllSelected_ListView : SetSelectDataIDs_ListView objData, selectDataIDs : ChangedSelectedItem_ListView
				//配列変数初期化
				DeleteAllData selectDataIDs
				return
			}
		}else {
			//何も選択していなくてもSelectLineDrawウィンドウ(矩形選択でオブジェクトを複数掴む枠)があったら非表示
			if wpEVENT = WM_APP || wpEVENT = (WM_APP+1) : HiddenGuidWindow hitID
			mode = MODE_NONE
			wpEVENT = 0
		}
		CallNextHookEx hHook, nCode, wp, lp
		return stat
	}

	SetObjData_BUTTONs ;記録を遅延させていたボタン群があればobjDataに登録

	if mode = MODE_NONE || mode = MODE_NONE_CHANGED {
		;// クリック　選択オブジェクトの追加
		switch wp
			case WM_LBUTTONDOWN
			case WM_RBUTTONDOWN
				;dupptr MOUSEHOOKSTRUCT,lp,12
				;hitHwnd = MOUSEHOOKSTRUCT(2)		;enableなオブジェクトはイベントを拾えないみたい。WindowFromPointも素通りする。
				SetLayered_SelectingObject SW_HIDE	;なのでクリックの前後で選択中の全オブジェクトをenableオンオフする
				hitHwnd = WindowFromPoint( ginfo_mx, ginfo_my )
				wpEVENT = 0
				foreach objData
					;背景をクリックした→はみ出しを許容またはクリックできないオブジェクトの特殊条件に当てはまるか確認
					if winHwnd_@ObjPosModDataClass( objData.cnt ) = hitHwnd {
						switch objType_@ObjPosModDataClass( objData.cnt )
							case "mes" : ;objType=="mes"だけオブジェクトの範囲内でクリックしてないか面倒を見てあげる(細い文字の上クリックするのは辛いから)
								point = ginfo_mx, ginfo_my : ScreenToClient objHwnd_@ObjPosModDataClass( objData.cnt ), varptr(point)
								if 0 <= point(0) && point(0) <= size_w2_@ObjPosModDataClass( objData.cnt ) && 0 <= point(1) && point(1) <= size_h2_@ObjPosModDataClass( objData.cnt ) : hitHwnd = objHwnd_@ObjPosModDataClass( objData.cnt ) ;"mes"オブジェクトのハンドルに置き換えてしまう
								swbreak
							case "line" : ;lineも範囲を太らせて判定する
								point = ginfo_mx, ginfo_my : ScreenToClient objHwnd_@ObjPosModDataClass( objData.cnt ), varptr(point)
								if -2 <= point(0) && point(0) <= size_w2_@ObjPosModDataClass( objData.cnt )+2 && -2 <= point(1) && point(1) <= size_h2_@ObjPosModDataClass( objData.cnt )+2 {
									cn = cnt
									repeat length.rxi 
										if WindowFromPoint( ginfo_mx+rxi.cnt, ginfo_my+ryi.cnt ) = objHwnd_@ObjPosModDataClass( objData.cn ) : hitHwnd = objHwnd_@ObjPosModDataClass( objData.cn ) : break ;"line"オブジェクトのハンドルに置き換えてしまう
									loop
								}
								swbreak
							default : ;拡張用の判定広げ
								//--------------------------------------
								// EXP拡張
								//======================================
								// *label_HitTest (オブジェクトをマウスで選択するときの特殊条件を登録するラベル(省略可))
								//--------------------------------------
								id = cnt
								foreach objExp@ObjPosModDataClass
									if objType_@ObjPosModDataClass( objData.id ) = objType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) {
										point = ginfo_mx, ginfo_my : ScreenToClient objHwnd_@ObjPosModDataClass( objData.id ), varptr(point)
										label_HitTest_@ObjPosModExpClass objExp@ObjPosModDataClass.cnt : mref _stat_,64:_stat_=0 : gosub refLabel@ObjPosModExpClass : if stat!0 : hitHwnd = objHwnd_@ObjPosModDataClass( objData.id ) : break
									}
								loop
						swend
					}
					;オブジェクトをクリックした
					if objHwnd_@ObjPosModDataClass( objData.cnt ) = hitHwnd {
						if mode = MODE_NONE_CHANGED && AlreadyHaveData(selectDataIDs, cnt) = 0 : ModeBreak ;既にオブジェクトを動かしていて、AddDataしようとしているオブジェクトが現在の選択の中になければ、一度今の選択をすべて解除する
						AddData selectDataIDs, cnt ;選択オブジェクトIDの保存
						mae_mx = ginfo_mx : mae_my = ginfo_my
						wpEVENT = wp
						;ドットウィンドウ表示
						if alignDot : ShowDotWindow winID_@ObjPosModDataClass( objData.cnt )
						break
					}
					;背景をクリックした→複数選択開始(但しobjType=="mes","line"廻りでなければ)
					if winHwnd_@ObjPosModDataClass( objData.cnt ) = hitHwnd {
						hitID = winID_@ObjPosModDataClass( objData.cnt )
						mae_mx = ginfo_mx : mae_my = ginfo_my
						wpEVENT = WM_APP + (wp == WM_RBUTTONDOWN) ;WM_APP(+1)を予約しておく。但しobjType=="mes","line"をクリックすることになるかもしれないからループは続ける
					}
				loop
				SetLayered_SelectingObject SW_SHOW	;選択中オブジェクトの表示を変更
				if CountData( selectDataIDs ) > 0 : return
				swbreak
			case WM_MOUSEMOVE
				if wpEVENT = WM_APP || wpEVENT = (WM_APP+1) : SelectLineDraw hitID, mae_mx, mae_my, ginfo_mx, ginfo_my, (wpEVENT == (WM_APP+1)) : swbreak ;SelectLineDrawウィンドウ(矩形選択でオブジェクトを複数掴む枠)を表示と更新
				if CountData( selectDataIDs ) > 0 {
					if wpEVENT = WM_LBUTTONDOWN : mode = MODE_MOVE
					if wpEVENT = WM_RBUTTONDOWN : mode = MODE_SIZE
					wpEVENT = 0
					ClearAllSelected_ListView ;リストビューに選択中のものがあれば解除する
					Clear_SCRIPTBOX           ;変更前/変更後スクリプトのmesboxをクリアする
				}
				swbreak
			case WM_LBUTTONUP
			case WM_RBUTTONUP
				if wpEVENT = WM_APP || wpEVENT = (WM_APP+1) {
					HiddenGuidWindow hitID ;SelectLineDrawウィンドウ(矩形選択でオブジェクトを複数掴む枠)を非表示
					foreach objData
						;矩形の中のオブジェクト([WM_APP+1]矩形と重なるオブジェクト)を選択状態にする
						if winID_@ObjPosModDataClass( objData.cnt ) = hitID {
							point.0 = mae_mx : if mae_mx > ginfo_mx : point.0 = ginfo_mx
							point.1 = mae_my : if mae_my > ginfo_my : point.1 = ginfo_my
							ScreenToClient winHwnd_@ObjPosModDataClass( objData.cnt ), varptr(point)
							x = point.0 : y = point.1
							point.0 = ginfo_mx : if mae_mx > ginfo_mx : point.0 = mae_mx
							point.1 = ginfo_my : if mae_my > ginfo_my : point.1 = mae_my
							ScreenToClient winHwnd_@ObjPosModDataClass( objData.cnt ), varptr(point)
							qx = point.0 : qy = point.1
							if wpEVENT = WM_APP {
								if x <= pos_x2_@ObjPosModDataClass( objData.cnt ) && pos_x2_@ObjPosModDataClass( objData.cnt ) + size_w2_@ObjPosModDataClass( objData.cnt ) <= qx && y <= pos_y2_@ObjPosModDataClass( objData.cnt ) && pos_y2_@ObjPosModDataClass( objData.cnt ) + size_h2_@ObjPosModDataClass( objData.cnt ) <= qy {
									if mode = MODE_NONE_CHANGED && AlreadyHaveData(selectDataIDs, cnt) = 0 : ModeBreak ;既にオブジェクトを動かしていて、AddDataしようとしているオブジェクトが現在の選択の中になければ、一度今の選択をすべて解除する
									AddData selectDataIDs, cnt : continue ;選択中オブジェクトIDの追加
								}
							}else {
								if x <= pos_x2_@ObjPosModDataClass( objData.cnt ) + size_w2_@ObjPosModDataClass( objData.cnt ) && pos_x2_@ObjPosModDataClass( objData.cnt ) <= qx && y <= pos_y2_@ObjPosModDataClass( objData.cnt ) + size_h2_@ObjPosModDataClass( objData.cnt ) && pos_y2_@ObjPosModDataClass( objData.cnt ) <= qy {
									if mode = MODE_NONE_CHANGED && AlreadyHaveData(selectDataIDs, cnt) = 0 : ModeBreak ;既にオブジェクトを動かしていて、AddDataしようとしているオブジェクトが現在の選択の中になければ、一度今の選択をすべて解除する
									AddData selectDataIDs, cnt : continue ;選択中オブジェクトIDの保存
								}
							}
						}
					loop
					SetLayered_SelectingObject SW_SHOW
				}
				wpEVENT = 0
				swbreak
		swend
		
	}else {
		;// ドラッグ　オブジェクトの移動、サイズ変更
		switch wp
			case WM_LBUTTONUP
			case WM_RBUTTONUP
				//pos,sizeを確定する
				foreach selectDataIDs : if selectDataIDs(cnt) < 0 : continue
					Set_pos_xy2_@ObjPosModDataClass objData.selectDataIDs(cnt), pos_x1_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), pos_y1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					Set_size_wh2_@ObjPosModDataClass objData.selectDataIDs(cnt), size_w1_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), size_h1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					; lineの場合タイプも確定
					if objType_@ObjPosModDataClass( objData.selectDataIDs(cnt) ) = "line" : Set_opt3_@ObjPosModDataClass objData.selectDataIDs(cnt), opt2_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					; ガイドがあれば非表示
					HiddenGuidWindow winID_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
				loop
				//move, size 終了
				if (mode = MODE_MOVING || mode = MODE_SIZING) {
					mode = MODE_NONE_CHANGED
				}else {
					mode = MODE_NONE
				}
				return
				swbreak
			case WM_MOUSEMOVE
				//オブジェクトの位置、サイズ 変更中
				getkey shift, 16
				changedObjNum = 0
				switch mode
					case MODE_MOVING
						if check_mx = ginfo_mx && check_my = ginfo_my : swbreak
					case MODE_MOVE
						check_mx = ginfo_mx : check_my = ginfo_my
						;掴んでいるオブジェクトに着目し、どれだけ動かせば良いかを計算
						grabID = GrabbingDataID( selectDataIDs )
						set.0 = pos_x2_@ObjPosModDataClass( objData.grabID ) + ginfo_mx - mae_mx
						set.1 = pos_y2_@ObjPosModDataClass( objData.grabID ) + ginfo_my - mae_my
						if alignDot {
							;ドットに合わせる
							if (set.0\dotInterval) > (dotInterval/2) { set.0 += dotInterval-(set.0\dotInterval) } else { set.0 -= (set.0\dotInterval) }
							if (set.1\dotInterval) > (dotInterval/2) { set.1 += dotInterval-(set.1\dotInterval) } else { set.1 -= (set.1\dotInterval) }
						}else : if alignObj {
							;付近のオブジェクトに吸着
							GetDiffNearestObject_Moving zureX, zureY, grabID, set.0, set.1, size_w2_@ObjPosModDataClass( objData.grabID ), size_h2_@ObjPosModDataClass( objData.grabID )
							if abs(zureX) <= objConnectDiff : set.0 += zureX
							if abs(zureY) <= objConnectDiff : set.1 += zureY
						}
						if shift=1 && ( abs(ginfo_mx - mae_mx) <  abs(ginfo_my - mae_my) ) : set.0 = pos_x2_@ObjPosModDataClass( objData.grabID ) ;+Shiftで縦横移動制限
						if shift=1 && ( abs(ginfo_mx - mae_mx) >= abs(ginfo_my - mae_my) ) : set.1 = pos_y2_@ObjPosModDataClass( objData.grabID ) ;
						;選択している全てのオブジェクトに反映させたいため差分値を計算
						set.0 = set.0 - pos_x2_@ObjPosModDataClass( objData.grabID )
						set.1 = set.1 - pos_y2_@ObjPosModDataClass( objData.grabID )
						;差分で動いていたらモードを更新
						if set.0 ! 0 || set.1 ! 0 : mode = MODE_MOVING
						
						;選択オブジェクトを差分値分すべて移動させる
						repeat length.selectDataIDs, 1
							cn = length.selectDataIDs - cnt
							if selectDataIDs(cn) < 0 : continue
							Set_pos_xy1_@ObjPosModDataClass objData.selectDataIDs(cn), pos_x2_@ObjPosModDataClass( objData.selectDataIDs(cn) ) + set.0, pos_y2_@ObjPosModDataClass( objData.selectDataIDs(cn) ) + set.1
							AutoSet_changedCount_@ObjPosModDataClass objData.selectDataIDs(cn)
							Set_hasBeenFixed_@ObjPosModDataClass objData.selectDataIDs(cn), 0 ;もし１度スクリプト書き換え済みでもまた動かしたら書き換えられるようにする
							//リストビューに反映
							SetData_ListView selectDataIDs(cn), changedObjNum : changedObjNum++
						loop
						swbreak
						
					case MODE_SIZING
						if check_mx = ginfo_mx && check_my = ginfo_my : swbreak
					case MODE_SIZE
						check_mx = ginfo_mx : check_my = ginfo_my
						;掴んでいるオブジェクトに着目し、どれだけ変更すれば良いかを計算
						grabID = GrabbingDataID( selectDataIDs )
						set.0 = size_w2_@ObjPosModDataClass( objData.grabID ) + ginfo_mx - mae_mx
						set.1 = size_h2_@ObjPosModDataClass( objData.grabID ) + ginfo_my - mae_my
						if alignDot {
							;ドットに合わせる
							if (set.0\dotInterval) > (dotInterval/2) { set.0 += dotInterval-(set.0\dotInterval) } else { set.0 -= (set.0\dotInterval) }
							if (set.1\dotInterval) > (dotInterval/2) { set.1 += dotInterval-(set.1\dotInterval) } else { set.1 -= (set.1\dotInterval) }
						}else : if alignObj {
							;付近のオブジェクトに吸着
							GetDiffNearestObject_Sizing zureX, zureY, grabID, pos_x2_@ObjPosModDataClass( objData.grabID ), pos_y2_@ObjPosModDataClass( objData.grabID ), set.0, set.1
							if abs(zureX) <= objConnectDiff : set.0 += zureX
							if abs(zureY) <= objConnectDiff : set.1 += zureY
						}
						if CountData( selectDataIDs ) = 1 : if objType_@ObjPosModDataClass( objData.grabID ) = "mes" : shift = 1 - shift ;特殊仕様(mes１つだけを掴んでいるときはshift押してないときに縦横同時合わせ操作にする)
						if shift=0 && ( abs(ginfo_mx - mae_mx) <  abs(ginfo_my - mae_my) ) : set.0 = size_w2_@ObjPosModDataClass( objData.grabID ) ;+Shiftでサイズの縦横同時合わせ
						if shift=0 && ( abs(ginfo_mx - mae_mx) >= abs(ginfo_my - mae_my) ) : set.1 = size_h2_@ObjPosModDataClass( objData.grabID ) ;
						;選択している全てのオブジェクトに反映させたいため差分値を計算
						set.0 = set.0 - size_w2_@ObjPosModDataClass( objData.grabID )
						set.1 = set.1 - size_h2_@ObjPosModDataClass( objData.grabID )
						;差分で動いていたらモードを更新
						if set.0 ! 0 || set.1 ! 0 : mode = MODE_SIZING
						
						;選択オブジェクトを差分値分すべてサイズ変更する
						repeat length.selectDataIDs, 1
							cn = length.selectDataIDs - cnt
							if selectDataIDs(cn) < 0 : continue
							if objType_@ObjPosModDataClass( objData.selectDataIDs(cn) ) = "picload" :continue ;picloadはサイズ不変
							if objType_@ObjPosModDataClass( objData.selectDataIDs(cn) ) = "mes" & opt3_@ObjPosModDataClass( objData.selectDataIDs(cn) ) = "sysfont" :continue ;sysfont mesはサイズ不変
							if objType_@ObjPosModDataClass( objData.selectDataIDs(cn) ) = "line" { ;lineだけ反転処理可
								set.2 = size_w2_@ObjPosModDataClass( objData.selectDataIDs(cn) ) + set.0 : if -objConnectDiff <= set.2 && set.2 < 0 : set.2 = 0
								set.3 = size_h2_@ObjPosModDataClass( objData.selectDataIDs(cn) ) + set.1 : if -objConnectDiff <= set.3 && set.3 < 0 : set.3 = 0
								switch opt3_@ObjPosModDataClass( objData.selectDataIDs(cn) )
									case 0 : if( set.2 < 0 & set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 1 } else : if( set.2 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 3 } else : if( set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 2 } else { Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 0 } : swbreak
									case 1 : if( set.2 < 0 & set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 0 } else : if( set.2 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 2 } else : if( set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 3 } else { Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 1 } : swbreak
									case 2 : if( set.2 < 0 & set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 3 } else : if( set.2 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 1 } else : if( set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 0 } else { Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 2 } : swbreak
									default: if( set.2 < 0 & set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 2 } else : if( set.2 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 0 } else : if( set.3 < 0 ){ Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 1 } else { Set_opt2_@ObjPosModDataClass objData.selectDataIDs(cn), 3 } : swbreak
								swend
								set.2 = abs( set.2 ) : set.3 = abs( set.3 )
								Set_size_wh1_@ObjPosModDataClass objData.selectDataIDs(cn), set.2, set.3
							}else {
								Set_size_wh1_@ObjPosModDataClass objData.selectDataIDs(cn), size_w2_@ObjPosModDataClass( objData.selectDataIDs(cn) ) + set.0, size_h2_@ObjPosModDataClass( objData.selectDataIDs(cn) ) + set.1
							}
							AutoSet_changedCount_@ObjPosModDataClass objData.selectDataIDs(cn)
							Set_hasBeenFixed_@ObjPosModDataClass objData.selectDataIDs(cn), 0 ;もし１度スクリプト書き換え済みでもまた動かしたら書き換えられるようにする
							//再描画が必要なオブジェクト(兼optパラメータ変更)
							RedrawObject objData,selectDataIDs(cn)
							//リストビューに反映
							SetData_ListView selectDataIDs(cn), changedObjNum : changedObjNum++
						loop
						swbreak
				swend
				//動かしたオブジェクトがなければbreak
				if changedObjNum = 0 : swbreak
				//描画リフレッシュ処理が必要なものを記憶するための変数を初期化
				InitValRefreshObjects
				//オブジェクトの位置/サイズを変更
				foreach selectDataIDs : if selectDataIDs(cnt) < 0 : continue
					hw = objHwnd_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					set.0 = pos_x1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					set.1 = pos_y1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					set.2 = size_w1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					set.3 = size_h1_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
					if objType_@ObjPosModDataClass( objData.selectDataIDs(cnt) ) = "line" : set.2++ : set.3++ ;lineだけ調整する
					SetWindowPos hw, HWND_NOTOPMOST, set(0),set(1),set(2),set(3), SWP_NOOWNERZORDER | SWP_NOZORDER
					if mode = MODE_SIZING {
						//オブジェクトの制限によるサイズ修正
						switch objType_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
							case "listbox"
							case "combox"
								GetWindowRect hw, varptr.rect ;一度サイズ指定したオブジェクトから本当にセットできたサイズを取得
								Set_size_h1_@ObjPosModDataClass objData.selectDataIDs(cnt), rect.3 - rect.1
								//リストビューにも再反映
								SetData_ListView selectDataIDs(cnt), -1
								swbreak
						swend
					}
					//描画リフレッシュ処理が必要なものを確認して記憶
					CheckRefreshObjects objData,selectDataIDs(cnt)
				loop
				//描画リフレッシュ処理実行（HSPウィンドウの一部にオブジェクト操作前後の描画が残ってしまうこと(バグ)があるため）
				ExecRefreshObjects objData
				//他のウィンドウとの接続性ガイドの表示
				if alignObj : GuidDraw GrabbingDataID( selectDataIDs )
				
				return
				swbreak
		swend
	}
	
	CallNextHookEx hHook, nCode, wp, lp
	return

//--------------------------------------
// メインウィンドウのサイズ変更
//--------------------------------------
*RESIZE@ObjPosMod
	resizeGsel = ginfo_sel
	gsel ginfo_intID
	MoveWindow hList, 0, 0, ginfo_winx, LISTVIEW_sizeY, 1
	MoveWindow hMesbox_maeScript, 0, SCRIPTBOX_posY, (ginfo_winx - (SCRIPTBOX_buttonW+10))/2, SCRIPTBOX_sizeY, 1
	MoveWindow hMesbox_atoScript, (ginfo_winx + (SCRIPTBOX_buttonW+10))/2, SCRIPTBOX_posY, (ginfo_winx - (SCRIPTBOX_buttonW+10))/2, SCRIPTBOX_sizeY, 1
	MoveWindow hButton_changeScript, (ginfo_winx-SCRIPTBOX_buttonW)/2, SCRIPTBOX_posY + (SCRIPTBOX_sizeY-SCRIPTBOX_buttonH)/2, SCRIPTBOX_buttonW, SCRIPTBOX_buttonH, 1
	MoveWindow hButton_listAllSelect, (ginfo_winx-LISTVIEW_buttonW)/2, SCRIPTBOX_posY, LISTVIEW_buttonW, LISTVIEW_buttonH, 1
	MoveWindow hwMain_child, 0, CHILDWINDOW_posY, ginfo_winx, CHILDWINDOW_sizeY, 1
	gsel resizeGsel
	return
//--------------------------------------
// リストビュー
//--------------------------------------
*NOTIFY@ObjPosMod
	dupptr nmhdr, lparam, 4*3, 4	// NMHDR structure
	if nmhdr.0 ! hList || nmhdr.0 = 0 : return
	switch nmhdr.2
		case NM_CLICK :
			ChangedSelectedItem_ListView : if 0 {
			#deffunc local ChangedSelectedItem_ListView ;オブジェクト移動後に選択アイテムを変更したいのでそこでも実行される
				;選択中のアイテムを取得
				GetSelectedItems_ListView selectedItems
				if stat = 0 {
					Clear_SCRIPTBOX : if 0 {
					#deffunc local Clear_SCRIPTBOX ;オブジェクト移動初めにリストのアイテム選択を解除するのでそこでもクリアしたい
						string256 = "→スクリプト変更→"
						sendmsg hButton_changeScript, WM_SETTEXT, 0, varptr.string256
						EnableWindow hButton_changeScript, 0
						mesbox_maeScript = "変更前のスクリプト"
						mesbox_atoScript = "変更後のスクリプト"
						sendmsg hMesbox_maeScript, WM_SETTEXT, 0, varptr.mesbox_maeScript
						sendmsg hMesbox_atoScript, WM_SETTEXT, 0, varptr.mesbox_atoScript
						return
					}
					return
				}
				;選択中アイテムの変更前/変更後スクリプトをmesboxに表示
				modIDs_count = 0
				mesbox_maeScript = ""
				mesbox_atoScript = ""
				allGreen = 1
				repeat stat
					lv_id = int.GetItem_ListView( selectedItems.cnt, 2 )
					modID = Get_modID_@ObjPosModDataClass( objData, lv_id )
					if hasBeenFixed_@ObjPosModDataClass( objData.modID ) = 0 : modIDs_count++ ;スクリプト書き換え済みのものは個数としてカウントしない
					if IsOpenedHspFile_@ObjPosModDataClass( objData.modID ) = 0 : allGreen = 0 ;選択アイテムがスクリプトエディタで開かれているかどうか確認
					mesbox_maeScript += maeScript_@ObjPosModDataClass( objData.modID )
					mesbox_atoScript += atoScript_@ObjPosModDataClass( objData.modID )
				loop
				;選択されたアイテムすべてのhspFileがエディタで開かれていないと「スクリプト変更」ボタンにならないようにする
				if allGreen : string256 = "→スクリプト変更→" : else : string256 = "ファイルを開く"
				sendmsg hButton_changeScript, WM_SETTEXT, 0, varptr.string256
				EnableWindow hButton_changeScript, ( modIDs_count > 0 ) ;スクリプト書き換え済みのものしか選択してなかったらボタンは押せないようにしとく
				sendmsg hMesbox_maeScript, WM_SETTEXT, 0, varptr.mesbox_maeScript
				sendmsg hMesbox_atoScript, WM_SETTEXT, 0, varptr.mesbox_atoScript
				return
			}
			swbreak
		case NM_DBLCLK :
			dupptr nmlistview, lparam, 4*11, 4
			dup iItem, nmlistview.3
			;リストビューからフォーカスアイテムのファイル名を取得してスクリプトエディタのタブを表示
			hspFilePath = Get_fullPath_@ObjPosModScriptClass( GetItem_ListView( iItem, 0 ) )
			HSED_ShowTab_filename@ObjPosModHsedModule hspFilePath
			if stat ! -1 {
				;リストビューからフォーカスアイテムの行番号を取得してその行にキャレットの位置を移動
				HSED_SetCaretLine@ObjPosModHsedModule stat, int.GetItem_ListView( iItem, 1 )
				HSED_SetForeground@ObjPosModHsedModule ;スクリプトエディタをアクティブ化
			}
			swbreak
		case NM_CUSTOMDRAW :
			dupptr nmlvcustomdraw, lparam, 4*15
			if nmlvcustomdraw.3 = CDDS_PREPAINT : return CDRF_NOTIFYITEMDRAW
			if nmlvcustomdraw.3 = CDDS_ITEMPREPAINT {
				lv_id = int.GetItem_ListView( nmlvcustomdraw.9, 2 )
				modID = Get_modID_@ObjPosModDataClass( objData, lv_id )
				if hasBeenFixed_@ObjPosModDataClass( objData.modID ) = 1 : nmlvcustomdraw.13 = $CCCCFF ;スクリプト書き換え済みの行は背景色を変える
			}
			swbreak
	swend
	return
//------------------------------------------------------------------------------
// End of メッセージ監視
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// サブルーチン
//------------------------------------------------------------------------------
//--------------------------------------
// 選択中オブジェクトとして見た目を変更
//--------------------------------------
#deffunc local SetLayered_SelectingObject int p1
	foreach selectDataIDs : if selectDataIDs(cnt) < 0 : continue
		switch objType_@ObjPosModDataClass( objData.selectDataIDs(cnt) )
			case "mes"
			case "boxf"
			case "line"
			case "circle"
			case "grect"
				SetLayeredWindowAttributes objHwnd_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), bgColorR|bgColorG<<8|bgColorB<<16, 255 - 127*(p1!=SW_HIDE), LWA_COLORKEY | LWA_ALPHA
				swbreak
			case "picload"
				SetLayeredWindowAttributes objHwnd_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), (bgColorR-PL_ALPHABUG_FIX)|(bgColorG-PL_ALPHABUG_FIX)<<8|(bgColorb-PL_ALPHABUG_FIX)<<16, 255 - 127*(p1!=SW_HIDE), LWA_COLORKEY | LWA_ALPHA ;picloadバグ対応
				swbreak
			case "chkbox"
			case "mesbox"
			case "input"
			case "combox"
			case "listbox"
			case "winobj"
			case "button"
				EnableWindow objHwnd_@ObjPosModDataClass( objData.selectDataIDs(cnt) ), (p1==SW_HIDE)
				swbreak
			default ; 標準命令になかったら拡張を探る
				id = selectDataIDs(cnt)
				foreach objExp@ObjPosModDataClass
					if objType_@ObjPosModDataClass( objData.id ) = objType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) {
						if layeredType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) ! 0 {
							SetLayeredWindowAttributes objHwnd_@ObjPosModDataClass( objData.id ), bgColorR|bgColorG<<8|bgColorB<<16, 255 - 127*(p1!=SW_HIDE), LWA_COLORKEY | LWA_ALPHA
						}else {
							EnableWindow objHwnd_@ObjPosModDataClass( objData.id ), (p1==SW_HIDE)
						}
					}
				loop
		swend
	loop
	return
	
//--------------------------------------
// オブジェクトの再描画 (サイズ変更時に必要なもの)
//--------------------------------------
#deffunc local RedrawObject array mod, int _id //RedrawObject objData,cnt って書いてもらう(ドットでなくカンマ)
	id = _id //Exp用処置
	switch objType_@ObjPosModDataClass( mod.id )
		case "mes"
			if opt5_@ObjPosModDataClass( mod.id ) = "sysfont" : swbreak ;"sysfont"の場合は入ってこないが一応
			GetMaxFontSizeWH outFSWH, mod.id, size_w1_@ObjPosModDataClass( mod.id ), size_h1_@ObjPosModDataClass( mod.id )
			Set_opt5_@ObjPosModDataClass mod.id, outFSWH(0)
			Set_size_w1_@ObjPosModDataClass mod.id, outFSWH(1)
			Set_size_h1_@ObjPosModDataClass mod.id, outFSWH(2)
			swbreak
		case "line"
			sel = ginfo_sel
			gsel objID_@ObjPosModDataClass( mod.id )
			redraw 0
			color bgColorR, bgColorG, bgColorB : boxf@hsp
			color colorR_@ObjPosModDataClass( mod.id ), colorG_@ObjPosModDataClass( mod.id ), colorB_@ObjPosModDataClass( mod.id )
			switch opt2_@ObjPosModDataClass( mod.id )
				case 0 : line@hsp                                     0,                                     0, size_w1_@ObjPosModDataClass( mod.id ), size_h1_@ObjPosModDataClass( mod.id ) : swbreak
				case 1 : line@hsp size_w1_@ObjPosModDataClass( mod.id ), size_h1_@ObjPosModDataClass( mod.id ),                                     0,                                     0 : swbreak
				case 2 : line@hsp                                     0, size_h1_@ObjPosModDataClass( mod.id ), size_w1_@ObjPosModDataClass( mod.id ),                                     0 : swbreak
				default: line@hsp size_w1_@ObjPosModDataClass( mod.id ),                                     0,                                     0, size_h1_@ObjPosModDataClass( mod.id ) : swbreak
			swend
			redraw 1
			gsel sel
			swbreak
		case "circle"
			sel = ginfo_sel
			gsel objID_@ObjPosModDataClass( mod.id )
			redraw 0
			color bgColorR, bgColorG, bgColorB : boxf@hsp
			color colorR_@ObjPosModDataClass( mod.id ), colorG_@ObjPosModDataClass( mod.id ), colorB_@ObjPosModDataClass( mod.id )
			circle@hsp 0, 0, size_w1_@ObjPosModDataClass( mod.id ), size_h1_@ObjPosModDataClass( mod.id ), opt1_@ObjPosModDataClass( mod.id )
			redraw 1
			gsel sel
			swbreak
		case "grect"
			sel = ginfo_sel
			dig = opt1_@ObjPosModDataClass( mod.id )
			dbl = sin(dig)*sin(dig)-cos(dig)*cos(dig)
			w = size_w1_@ObjPosModDataClass( mod.id )
			h = size_h1_@ObjPosModDataClass( mod.id )
			gsel objID_@ObjPosModDataClass( mod.id )
			color bgColorR, bgColorG, bgColorB : boxf@hsp
			color colorR_@ObjPosModDataClass( mod.id ), colorG_@ObjPosModDataClass( mod.id ), colorB_@ObjPosModDataClass( mod.id )
			grect@hsp (w+1)/2, (h+1)/2, dig, int((cos(dig)*w-sin(dig)*h)/(-dbl)*10+5)/10, int((sin(dig)*w-cos(dig)*h)/dbl*10+5)/10
			redraw 1
			gsel sel
			swbreak
		default ; 標準命令になかったら拡張を探る
			//--------------------------------------
			// EXP拡張
			//======================================
			// *label_RedrawObj (エディタ書き換え処理を登録するラベル)
			//--------------------------------------
			foreach objExp@ObjPosModDataClass
				if objType_@ObjPosModDataClass( mod.id ) = objType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) {
					label_RedrawObj_@ObjPosModExpClass objExp@ObjPosModDataClass.cnt : mref _stat_,64:_stat_=0 : gosub refLabel@ObjPosModExpClass : if stat!0 : hitHwnd = objHwnd_@ObjPosModDataClass( objData.id ) : break
				}
			loop
	swend
	return

//--------------------------------------
// オブジェクト操作後にどうしても描画リフレッシュが必要なものの処理(ほぼGROUPBOXの為だけの処理)
//--------------------------------------
//初期化
#deffunc local InitValRefreshObjects
	refreshObjCount = 0 ; : dim refreshObjIDs, 0
	return
//登録
#deffunc local CheckRefreshObjects array mod, int _id //CheckRefreshObjects objData,cnt って書いてもらう(ドットでなくカンマ)
	id = _id //Exp用処置
	switch objType_@ObjPosModDataClass( mod.id )
		case "mes"
		case "boxf"
		case "line"
		case "circle"
		case "grect"
		case "picload"
		case "chkbox"
		case "mesbox"
		case "input"
		case "combox"
		case "listbox"
		case "winobj"
		case "button"
			swbreak
		default
			foreach objExp@ObjPosModDataClass
				if objType_@ObjPosModDataClass( mod.id ) = objType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) {
					if layeredType_@ObjPosModExpClass( objExp@ObjPosModDataClass.cnt ) & 2 : refreshObjIDs( refreshObjCount ) = id : refreshObjCount++
				}
			loop
	swend
	return
//実行
#deffunc local ExecRefreshObjects array mod
	refreshWinCount = 0 ; : dim refreshWinIDs, 0
	refreshRect = 0,0,0,0
	sel = ginfo_sel
	repeat refreshObjCount
		ShowWindow objHwnd_@ObjPosModDataClass( mod.refreshObjIDs(cnt) ),0
		//winIDを集める(重複なしで)
		refreshWinIDs( refreshWinCount ) = winID_@ObjPosModDataClass( mod.refreshObjIDs(cnt) ) : refreshWinCount++
		repeat refreshWinCount - 1
			if refreshWinIDs( cnt ) = refreshWinIDs( refreshWinCount - 1 ) : refreshWinCount-- : break ;いったん末尾に足したけど重複してたら削ることで重複なしになる
		loop
	loop
	repeat refreshWinCount
		gsel refreshWinIDs( cnt )
		redraw 1
	loop
	repeat refreshObjCount
		ShowWindow objHwnd_@ObjPosModDataClass( mod.refreshObjIDs(cnt) ),1
	loop
	gsel sel
	return
	
//--------------------------------------
// 掴んでいるオブジェクトに一番近い他のオブジェクトまでの距離を返す (オブジェクト移動用)
//--------------------------------------
#deffunc local GetDiffNearestObject_Moving var nearDiffX, var nearDiffY, int _id, int px, int py, int pw, int ph
	id = _id //Exp用処置
	g_sel = ginfo_sel
	winID = winID_@ObjPosModDataClass( objData.id )
	gsel winID
	
	nearDiffX = 10000 : nearDiffY = 10000
	foreach objData
		if winID_@ObjPosModDataClass( objData.cnt ) ! winID : continue
		if cnt = id {
			;掴んでいる(Grab)オブジェクトのIDだったときはウィンドウのx,y,w,hと比較させる
			x = 0
			y = 0
			w = ginfo_winx
			h = ginfo_winy
		}else {
			;選択しているオブジェクトは(Grabに限らず)比較はしない
			dataID = cnt
			continueFlg = 0
			foreach selectDataIDs
				if selectDataIDs(cnt) < 0 :continue
				if selectDataIDs(cnt) = dataID : continueFlg=1 : break
			loop
			if continueFlg : continue
			x = pos_x2_@ObjPosModDataClass( objData.cnt )
			y = pos_y2_@ObjPosModDataClass( objData.cnt )
			w = size_w2_@ObjPosModDataClass( objData.cnt )
			h = size_h2_@ObjPosModDataClass( objData.cnt )
		}
		d = (x    ) - (px     ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x    ) - (px+pw  ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x    ) - (px+pw/2) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w  ) - (px     ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w  ) - (px+pw  ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w  ) - (px+pw/2) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w/2) - (px     ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w/2) - (px+pw  ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w/2) - (px+pw/2) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (y    ) - (py     ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y    ) - (py+ph  ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y    ) - (py+ph/2) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h  ) - (py     ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h  ) - (py+ph  ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h  ) - (py+ph/2) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h/2) - (py     ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h/2) - (py+ph  ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h/2) - (py+ph/2) : if abs(d) < abs(nearDiffY) : nearDiffY = d
	loop
	
	gsel g_sel
	return

//--------------------------------------
// 掴んでいるオブジェクトに一番近い他のオブジェクトまでの距離を返す (オブジェクトサイズ変更用)
//--------------------------------------
#deffunc local GetDiffNearestObject_Sizing var nearDiffX, var nearDiffY, int _id, int px, int py, int pw, int ph
	id = _id //Exp用処置
	g_sel = ginfo_sel
	winID = winID_@ObjPosModDataClass( objData.id )
	gsel winID
	
	nearDiffX = 10000 : nearDiffY = 10000
	foreach objData
		if winID_@ObjPosModDataClass( objData.cnt ) ! winID : continue
		if cnt = id {
			;掴んでいる(Grab)オブジェクトのIDだったときはウィンドウのx,y,w,hと比較させる
			x = 0
			y = 0
			w = ginfo_winx
			h = ginfo_winy
		}else {
			;選択しているオブジェクトは(Grabに限らず)比較はしない
			dataID = cnt
			continueFlg = 0
			foreach selectDataIDs
				if selectDataIDs(cnt) < 0 :continue
				if selectDataIDs(cnt) = dataID : continueFlg=1 : break
			loop
			if continueFlg : continue
			x = pos_x2_@ObjPosModDataClass( objData.cnt )
			y = pos_y2_@ObjPosModDataClass( objData.cnt )
			w = size_w2_@ObjPosModDataClass( objData.cnt )
			h = size_h2_@ObjPosModDataClass( objData.cnt )
		}
		d = (x    ) - (px+pw  ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x    ) - (px+pw/2) : if abs(d) < abs(nearDiffX) : nearDiffX = d*2
		d = (x+w  ) - (px+pw  ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w  ) - (px+pw/2) : if abs(d) < abs(nearDiffX) : nearDiffX = d*2
		d = (x+w/2) - (px+pw  ) : if abs(d) < abs(nearDiffX) : nearDiffX = d
		d = (x+w/2) - (px+pw/2) : if abs(d) < abs(nearDiffX) : nearDiffX = d*2
		d = (y    ) - (py+ph  ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y    ) - (py+ph/2) : if abs(d) < abs(nearDiffY) : nearDiffY = d*2
		d = (y+h  ) - (py+ph  ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h  ) - (py+ph/2) : if abs(d) < abs(nearDiffY) : nearDiffY = d*2
		d = (y+h/2) - (py+ph  ) : if abs(d) < abs(nearDiffY) : nearDiffY = d
		d = (y+h/2) - (py+ph/2) : if abs(d) < abs(nearDiffY) : nearDiffY = d*2
	loop
	
	gsel g_sel
	return

//--------------------------------------
// 掴んでいるオブジェクトの座標と一致している他のオブジェクトとの位置関係をガイドウィンドウに描画
//--------------------------------------
#deffunc local GuidDraw int _id
	id = _id //Exp用処置
	gg_sel = ginfo_sel
	winID = winID_@ObjPosModDataClass( objData.id )
	qx = pos_x1_@ObjPosModDataClass( objData.id )
	qy = pos_y1_@ObjPosModDataClass( objData.id )
	qw = size_w1_@ObjPosModDataClass( objData.id )
	qh = size_h1_@ObjPosModDataClass( objData.id )
	gsel widGuids(winID)
	color
	if IsWindowVisible( hwGuids(winID) ) = 0 : boxf@hsp : ShowGuidWindow winID
	redraw 0
	boxf@hsp
	color 0,255,0

	foreach objData
		if winID_@ObjPosModDataClass( objData.cnt ) ! winID : continue
		if cnt = id {
			;掴んでいる(Grab)オブジェクトのIDだったときはウィンドウのx,y,w,hと比較させる
			x = 0
			y = 0
			w = ginfo_winx
			h = ginfo_winy
		}else {
			;選択しているオブジェクトは(Grabに限らず)比較はしない
			dataID = cnt
			continueFlg = 0
			foreach selectDataIDs
				if selectDataIDs(cnt) < 0 :continue
				if selectDataIDs(cnt) = dataID : continueFlg=1 : break
			loop
			if continueFlg : continue
			x = pos_x1_@ObjPosModDataClass( objData.cnt )
			y = pos_y1_@ObjPosModDataClass( objData.cnt )
			w = size_w1_@ObjPosModDataClass( objData.cnt )
			h = size_h1_@ObjPosModDataClass( objData.cnt )
		}
		minX = x   : if x   > qx    : minX = qx
		maxX = x+w : if x+w < qx+qw : maxX = qx+qw
		minY = y   : if y   > qy    : minY = qy
		maxY = y+h : if y+h < qy+qh : maxY = qy+qh
		if (x    ) = (qx     ) : line@hsp x, minY, x, maxY
		if (x    ) = (qx+qw  ) : line@hsp x, minY, x, maxY
		if (x    ) = (qx+qw/2) : line@hsp x, minY, x, maxY
		if (x+w  ) = (qx     ) : line@hsp x+w, minY, x+w, maxY
		if (x+w  ) = (qx+qw  ) : line@hsp x+w, minY, x+w, maxY
		if (x+w  ) = (qx+qw/2) : line@hsp x+w, minY, x+w, maxY
		if (x+w/2) = (qx     ) : line@hsp x+w/2, minY, x+w/2, maxY
		if (x+w/2) = (qx+qw  ) : line@hsp x+w/2, minY, x+w/2, maxY
		if (x+w/2) = (qx+qw/2) : line@hsp x+w/2, minY, x+w/2, maxY
		if (y    ) = (qy     ) : line@hsp minX, y, maxX, y
		if (y    ) = (qy+qh  ) : line@hsp minX, y, maxX, y
		if (y    ) = (qy+qh/2) : line@hsp minX, y, maxX, y
		if (y+h  ) = (qy     ) : line@hsp minX, y+h, maxX, y+h
		if (y+h  ) = (qy+qh  ) : line@hsp minX, y+h, maxX, y+h
		if (y+h  ) = (qy+qh/2) : line@hsp minX, y+h, maxX, y+h
		if (y+h/2) = (qy     ) : line@hsp minX, y+h/2, maxX, y+h/2
		if (y+h/2) = (qy+qh  ) : line@hsp minX, y+h/2, maxX, y+h/2
		if (y+h/2) = (qy+qh/2) : line@hsp minX, y+h/2, maxX, y+h/2
	loop
	redraw 1
	gsel gg_sel
	return
	
//--------------------------------------
// 矩形選択でオブジェクトを複数掴む枠を表示
//--------------------------------------
#deffunc local SelectLineDraw int _id, int px1, int py1, int px2, int py2, int red
	id = _id //Exp用処置
	gg_sel = ginfo_sel
	gsel id
	hw = hwnd
	gsel widGuids(id)
	color
	if IsWindowVisible( hwGuids(id) ) = 0 : boxf@hsp : ShowGuidWindow id
	redraw 0
	boxf@hsp
	
	point = px1,py1
	ScreenToClient hw, varptr(point)
	x = point.0
	y = point.1
	point = px2,py2
	ScreenToClient hw, varptr(point)
	qx = point.0
	qy = point.1
	
	color 100,100,255
	if red = 1 : color 255,100,100
	line@hsp x,y, qx,y
	line@hsp qx,y, qx,qy
	line@hsp qx,qy, x,qy
	line@hsp x,qy, x,y
	redraw 1
	gsel gg_sel
	return
//------------------------------------------------------------------------------
// End of サブルーチン
//------------------------------------------------------------------------------
	
//------------------------------------------------------------------------------
// 選択中オブジェクトID配列 操作用の命令
//==============================================================================
// array v :モジュール変数objData@ObjPosModDataClassのIDを記憶する配列変数
// 配列例）0,-1,-1,3,1
// Removeしたり再Addしたところが軽率に-1になるためループ頭で-1を弾いて使用する。
// 配列の最後尾に掴んでいる(マウスでドラッグしている)オブジェクトのIDを置くようにしている。
//------------------------------------------------------------------------------
#deffunc local InitData array v
	dim v, 1 : v.0 = -2
	return
#defcfunc local GrabbingDataID array v ;掴んでいるDataIDを返す(配列最後尾)
	i=-1
	foreach v
		cn = length(v)-1-cnt
		if v.cn >= 0 : i = v.cn : break
	loop
	return i
#defcfunc local CountData array v
	count=0
	foreach v
		if v.cnt >= 0 : count++
	loop
	return count
#defcfunc local AlreadyHaveData array v, int p1
	i=0
	foreach v
		if v.cnt < 0 : continue
		if v.cnt = p1 : i=1 : break
	loop
	return i
#deffunc local AddData array v, int p1
	;既に持っていればdeleteして最後尾にadd。掴んでいるDataを分かるようにする。
	RemoveData v, p1
	;まだ何も入ってなければ.0に代入
	if v.0 = -2 : v.0 = p1 : return
	v( length.v ) = p1
	return
#deffunc local RemoveData array v, int p1
	foreach v
		if v.cnt = p1 : v.cnt = -1 : break
	loop
	if CountData(v) = 0 : InitData v
	return
#deffunc local DeleteAllData array v
	InitData v
	return
//------------------------------------------------------------------------------
// End of 選択中オブジェクトID操作用の命令
//------------------------------------------------------------------------------

#global
//------------------------------------------------------------------------------
// End of ObjPosMod モジュール本体
//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

#endif
#endif
//------------------------------------------------------------------------------
// End of Object Pos Module 
//＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
//￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣

//------------------------------------------------------------------------------
// Changelogs
//==============================================================================
// Ver.2.0         2022/ 4/ 1
//----------------------------
// - 拡張オブジェクト(独自モジュール)を登録できるように大幅改造。
// - リストの全選択ボタンを追加。
// - sysfontに対応できていなかったを修正。
// - HSP3.7β2から修正予定のpicloadバグFixにも対応できるように修正。
// - その他、細かい変更やバグの修正。
//
// Ver.1.2         2022/ 1/24
//----------------------------
// - スクリプト末尾の方のオブジェクトから書き換えていくようにした。
// - 右クリックで矩形選択するとオブジェクトに少しでも重なれば選択できるようにした。
// - オブジェクトを動かした後連続して他を動かすとき前回選択を解除するようにした。
// - listbox,comboxにオブジェクトサイズの制限があるのである程度頑張って対処した。
// - その他、細かい変更やバグの修正。
//
// Ver.1.1         2022/ 1/21
//----------------------------
// - inputに指定する変数が数値型の場に強制終了してしまうバグを修正。
//
// Ver.1.0         2022/ 1/19
//----------------------------
// - リリース。
//
//------------------------------------------------------------------------------
